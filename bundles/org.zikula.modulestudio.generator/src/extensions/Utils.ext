
import modulestudio;
extension org::eclipse::xtend::util::stdlib::io;


/* app related functions */
cached String msVersion() :
    "0.5.2";
cached String msUrl() :
    "http://modulestudio.de";



/* not used yet, just for testing */
cached String constantName(Action this) :
	"ACTION_" + name.toUpperCase();
 
cached String constantName(ActionEvent this) :
	"EVENT_" + name.toUpperCase();

cached String msconcat(String a, String b) :
    a.replaceAll(a, a + b);

/*
 * naming extensions
 */
cached String appName(Application this) :
	name.formatForCode().toFirstUpper();

cached String prefix(Application this) :
    prefix.formatForDB();

cached String formatForCode(String s) :
	JAVA extensions.Utils.formatForCode(java.lang.String);
cached String formatForCodeCapital(String s) :
	s.formatForCode().toFirstUpper();
cached String formatForDB(String s) :
	JAVA extensions.Utils.formatForDB(java.lang.String);
cached String formatForDisplay(String s) :
	JAVA extensions.Utils.formatForDisplay(java.lang.String);
cached String formatForDisplayCapital(String s) :
	JAVA extensions.Utils.formatForDisplayCapital(java.lang.String);

cached String displayBool(Boolean b) :
    ((b) ? 'true' : 'false');


// return all entities with leading = true
cached getLeadingEntity(Application this) :
    models.entities.select(e|e.leading == true).get(0);

cached boolean hasImageFields(Application this) :
    models.entities.exists(e|e.hasImageFields());

cached boolean hasColourFields(Application this) :
    models.entities.exists(e|e.hasColourFields());

cached getUserFields(Application this) :
    models.entities.fields.typeSelect(UserField);
cached boolean hasUserFields(Application this) :
    !getUserFields().isEmpty;

cached boolean hasUploads(Application this) :
    !models.entities.fields.typeSelect(UploadField).isEmpty;

cached getUploadEntities(Application this) :
    models.entities.select(e|e.fields.typeSelect(UploadField).size > 0);

cached boolean hasLoggable(Application this) :
    models.entities.select(e|e.loggable);
cached boolean hasSluggable(Application this) :
    models.entities.exists(e|e.hasSluggableFields());
cached boolean hasSortable(Application this) :
    models.entities.exists(e|e.hasSortableFields());
cached boolean hasTimestampable(Application this) :
    models.entities.exists(e|e.hasTimestampableFields());
cached boolean hasTranslatable(Application this) :
    !getTranslatableEntities().isEmpty;
cached getTranslatableEntities(Application this) :
    models.entities.select(e|e.hasTranslatableFields());
cached boolean hasTrees(Application this) :
    !getTreeEntities().isEmpty;
cached getTreeEntities(Application this) :
    models.entities.select(e|e.tree != EntityTreeType::NONE);


cached boolean hasEditActions(Application this) :
    !getEditActions().isEmpty;

cached getEditActions(Application this) :
    controllers.controllers.actions.typeSelect(EditAction);

cached boolean needsConfig(Application this) :
    !models.variables.vars.isEmpty;

cached String configControllerType(Application this) :
    ((!controllers.controllers.typeSelect(AdminController).isEmpty) ? 'modulestudio::AdminController'
        : ((!controllers.controllers.typeSelect(UserController).isEmpty) ? 'modulestudio::UserController'
            : controllers.controllers.get(0).metaType.toString()
    ));
cached String configController(Application this) :
    configControllerType().replaceAll('modulestudio::', '').replaceAll('Controller', '');

cached String getUniqueRelationNameForJs(JoinRelationship this, Application app, Entity targetEntity, Boolean many, Boolean incoming, String relationAliasName) :
    app.prefix()
    .msconcat(targetEntity.name.formatForCodeCapital())
    .msconcat('_')
    .msconcat(relationAliasName);

// return model container which are default data sources
cached getDefaultDataSource(Application this) :
    models.select(e|e.defaultDataSource == true).get(0);


cached String fullEntityName(Entity this) :
    container.application.prefix().msconcat("_").msconcat(name.formatForDB());

cached String getEntityNameSingularPlural(Entity this, Boolean usePlural) :
    ((usePlural) ? nameMultiple : name);

cached String idField(Entity this) :
    getPrimaryKeyField().name.formatForDB();

cached boolean hasNormalIndexes(Entity this) :
    !getNormalIndexes().isEmpty;
cached getNormalIndexes(Entity this) :
    indexes.select(e|e.type == EntityIndexType::NORMAL);

cached boolean hasUniqueIndexes(Entity this) :
    !getUniqueIndexes().isEmpty;
cached getUniqueIndexes(Entity this) :
    indexes.select(e|e.type == EntityIndexType::UNIQUE);

// return all derived fields (excluding calculated fields)
cached getDerivedFields(Entity this) :
    fields.typeSelect(DerivedField);
cached getUniqueDerivedFields(Entity this) :
    getDerivedFields().select(e|e.unique);
// return all fields with leading = true
cached getLeadingField(Entity this) :
    getDerivedFields().select(e|e.leading == true).get(0);

// return all fields with primaryKey = true
/* TODO: support composite keys */
cached getPrimaryKeyField(Entity this) :
    getDerivedFields(this).select(e|e.primaryKey == true).get(0);

cached getUserFields(Entity this) :
    fields.typeSelect(UserField);
cached boolean hasUploadFields(Entity this) :
    !getUploadFields().isEmpty;
cached getUploadFields(Entity this) :
    fields.typeSelect(UploadField);

cached boolean hasImageFields(Entity this) :
    !getImageFields().isEmpty;
cached getImageFields(Entity this) :
    getUploadFields().select(e|e.allowedExtensions.split(", ").forAll(ext|ext == 'gif' || ext == 'jpeg' || ext == 'jpg' || ext == 'png'));

cached boolean hasColourFields(Entity this) :
    !getColourFields().isEmpty;
cached getColourFields(Entity this) :
    getDerivedFields().typeSelect(StringField).select(e|e.htmlcolour != null && e.htmlcolour != "");

cached boolean hasSluggableFields(Entity this) :
    !getSluggableFields().isEmpty;
cached getSluggableFields(Entity this) :
    fields.typeSelect(DerivedField).select(e|e.sluggablePosition > 0);

cached boolean hasSortableFields(Entity this) :
    !getSortableFields().isEmpty;
cached getSortableFields(Entity this) :
    fields.typeSelect(IntegerField).select(e|e.sortablePosition > 0);

cached boolean hasTimestampableFields(Entity this) :
    !getTimestampableFields().isEmpty;
cached getTimestampableFields(Entity this) :
    fields.typeSelect(AbstractDateField).select(e|e.timestampable != EntityTimestampableType::NONE);

cached boolean hasTranslatableFields(Entity this) :
    !getTranslatableFields().isEmpty;
cached getTranslatableFields(Entity this) :
    fields.typeSelect(DerivedField).select(e|e.translatable);




/** obsolete */
cached getPointingRelations(IntegerField this) :
    entity.incoming.typeSelect(JoinRelationship).select(e|e.source.idField() == name.formatForDB());

cached String subFolderPathSegment(UploadField this) :
    (subFolderName != null && subFolderName != "") ? subFolderName.formatForDB() : name.formatForDB();

cached String namingSchemeAsInt(UploadField this) :
    switch (namingScheme) {
        case UploadNamingScheme::ORIGINALWITHCOUNTER    : '0'
        case UploadNamingScheme::RANDOMCHECKSUM         : '1'
        case UploadNamingScheme::FIELDNAMEWITHCOUNTER   : '2'
        default: '0'
    };

cached String asConstant(EntityChangeTrackingPolicy policy) :
    switch (policy) {
        case EntityChangeTrackingPolicy::DEFERRED_IMPLICIT      : 'DEFERRED_IMPLICIT'
        case EntityChangeTrackingPolicy::DEFERRED_EXPLICIT      : 'DEFERRED_EXPLICIT'
        case EntityChangeTrackingPolicy::NOTIFY                 : 'NOTIFY'
        default: 'DEFERRED_IMPLICIT'
    };
cached String asConstant(EntitySlugStyle slugStyle) :
    switch (slugStyle) {
        case EntitySlugStyle::LOWERCASE                : 'default'
        case EntitySlugStyle::CAMEL                    : 'camel'
        default: 'default'
    };
cached String asConstant(EntityTimestampableType tsType) :
    switch (tsType) {
        case EntityTimestampableType::UPDATE            : 'update'
        case EntityTimestampableType::CREATE            : 'create'
        case EntityTimestampableType::CHANGE            : 'change'
        default: 'update'
    };
cached String asConstant(EntityTreeType treeType) :
    switch (treeType) {
        case EntityTreeType::NONE                       : ''
        case EntityTreeType::NESTED                     : 'nested'
        case EntityTreeType::CLOSURE                    : 'closure'
        default: ''
    };
cached String asConstant(RelationFetchType fetchType) :
    switch (fetchType) {
        case RelationFetchType::LAZY                    : 'LAZY'
        case RelationFetchType::EAGER                   : 'EAGER'
        case RelationFetchType::EXTRA_LAZY              : 'EXTRA_LAZY'
        default: 'LAZY'
    };

cached hasNotifyPolicy(Entity this) :
    (changeTrackingPolicy == EntityChangeTrackingPolicy::NOTIFY);

// return all join relations (excluding inheritance)
cached getJoinRelations(Models this) :
    relations.typeSelect(JoinRelationship);

cached getOutgoingCollections(Entity this) :
    outgoing.typeSelect(OneToManyRelationship).union(outgoing.typeSelect(ManyToManyRelationship));
cached getIncomingCollections(Entity this) :
    outgoing.typeSelect(ManyToOneRelationship).select(e|e.bidirectional).union(outgoing.typeSelect(ManyToManyRelationship).select(e|e.bidirectional));
cached getCollections(Entity this) :
    getOutgoingCollections().union(getIncomingCollections());

cached hasOutgoingCollections(Entity this) :
	!getOutgoingCollections().isEmpty;
cached hasIncomingCollections(Entity this) :
	!getIncomingCollections().isEmpty;
cached hasCollections(Entity this) :
	!getCollections().isEmpty;

cached isInheriting(Entity this) :
    !outgoing.typeSelect(InheritanceRelationship).isEmpty;
cached InheritanceRelationship getInheritanceRelation(Entity this) :
    outgoing.typeSelect(InheritanceRelationship).get(0);
cached Entity parentType(Entity this) :
    getInheritanceRelation().target;

cached isInheriter(Entity this) :
    !incoming.typeSelect(InheritanceRelationship).isEmpty;
cached getChildRelations(Entity this) :
    incoming.typeSelect(InheritanceRelationship);

/* if we have id or fooid return fooid; otherwise return the actual field name of the referenced field */
cached relationFieldName(Entity refEntity, String refField) :
    (refField.toLowerCase() == 'id' || refField.toLowerCase() == refEntity.idField()) ? refEntity.idField() : refEntity.fields.select(e|e.name == refField).get(0).name.formatForCode();

cached String isDefaultIdField(DerivedField this) :
    {'id', this.entity.name.formatForDB() + 'id', this.entity.name.formatForDB() + '_id'}.contains(this.name.formatForDB());
/* get local field for 1:1 and 1:n * /
cached getRelationLocalField(JoinRelationship this, Boolean incoming) :
    (!incoming) ? source.relationFieldName(sourceField) : (!isDefaultIdField(targetField, target) ? target.relationFieldName(targetField) : source.relationFieldName(sourceField));
/* get foreign field for 1:1 and 1:n * / 
cached getRelationForeignField(JoinRelationship this, Boolean incoming) :
    (incoming) ? source.relationFieldName(sourceField) : (!isDefaultIdField(targetField, target) ? target.relationFieldName(targetField) : source.relationFieldName(sourceField));

cached String getTargetMultiplicity(JoinRelationship this) :
    'Many';
cached String getTargetMultiplicity(OneToOneRelationship this) :
    'One';
cached String getTargetMultiplicity(ManyToOneRelationship this) :
    'One';
*/

/* retrieve integer value defining which relation edit type will be implemented
 * this mapping is done to have a more appropriate logic inside the generator
 * possible values:
 *    0    Nothing is being done
 *    1    Select related object
 *    2    Create and edit related object
 *    3    Combination of 1 and 2
 */
cached Integer getEditStageCode(JoinRelationship this, Boolean incoming) :
    switch (editType) {
       case RelationEditType::ACTIVE_NONE_PASSIVE_CHOOSE    : ((incoming) ? 1 : 0)
       case RelationEditType::ACTIVE_NONE_PASSIVE_EDIT      : ((incoming) ? 3 : 0)
       case RelationEditType::ACTIVE_CHOOSE_PASSIVE_NONE    : ((incoming) ? 3 : 2)  // invalid --> default as fallback
       case RelationEditType::ACTIVE_EDIT_PASSIVE_CHOOSE    : ((incoming) ? 1 : 2)
       case RelationEditType::ACTIVE_EDIT_PASSIVE_EDIT      : ((incoming) ? 3 : 2)  // default
       case RelationEditType::ACTIVE_EDIT_PASSIVE_NONE      : ((incoming) ? 3 : 2)  // invalid --> default as fallback
       default: ((incoming) ? 3 : 2)
    };

/* specialisation for many-to-many relations */
cached Integer getEditStageCode(ManyToManyRelationship this, Boolean incoming) :
    switch (editType) {
       case RelationEditType::ACTIVE_NONE_PASSIVE_CHOOSE    : ((incoming) ? 1 : 0)
       case RelationEditType::ACTIVE_NONE_PASSIVE_EDIT      : ((incoming) ? 3 : 0)
       case RelationEditType::ACTIVE_CHOOSE_PASSIVE_NONE    : ((incoming) ? 0 : 1)
       case RelationEditType::ACTIVE_EDIT_PASSIVE_CHOOSE    : ((incoming) ? 1 : 3)
       case RelationEditType::ACTIVE_EDIT_PASSIVE_EDIT      : ((incoming) ? 3 : 3)  // default
       case RelationEditType::ACTIVE_EDIT_PASSIVE_NONE      : ((incoming) ? 0 : 3)
       default: ((incoming) ? 3 : 3)
    };


/* controller related extensions */
cached String name(Controller this) :
    name.formatForDB();

cached getUserControllers(Application this) :
    controllers.controllers.typeSelect(UserController);
cached boolean hasUserController(Application this) :
    !getUserControllers().isEmpty;
cached getUserController(Application this) :
    getUserControllers().get(0);

cached boolean hasActions(Controller controller, String type) :
	switch (type) {
	   case 'main'     : !controller.actions.typeSelect(MainAction).isEmpty 
	   case 'view'     : !controller.actions.typeSelect(ViewAction).isEmpty 
	   case 'display'  : !controller.actions.typeSelect(DisplayAction).isEmpty 
	   case 'edit'     : !controller.actions.typeSelect(EditAction).isEmpty
	   case 'delete'   : !controller.actions.typeSelect(DeleteAction).isEmpty
	   case 'custom'   : !controller.actions.typeSelect(CustomAction).isEmpty 
	   default : false
	};


/*
 * extensions that are independent of a specific model element,
 */

cached String fieldTypeAsString(DerivedField f) :
    f.metaType.toString().replaceAll("modulestudio::", "").replaceAll("Field", "").toLowerCase();
// required for own sub types like user, email, url, upload
cached String fieldTypeAsString(AbstractIntegerField f) :
    // choose mapping type depending on length
    // a SMALLINT ranges up to 32767 and is therefore not appropriate for 5 digits
    // an INT ranges up to 2147483647 and is therefore good for up to 9 digits
    // maximal length of 18 is enforced in model validation
    (
    	(f.length < 5) ? 'smallint' : (
    		(f.length < 10) ? 'integer' : 'bigint'
    	)
    );
cached String fieldTypeAsString(AbstractStringField f) :
    'string';

cached String timestamp() :
	JAVA extensions.Utils.timestamp();

cached Boolean isProgressMonitor(Object monitor) :
    JAVA extensions.Utils.isProgressMonitor(java.lang.Object);

cached String subTask(Object monitor, String title) :
    monitor.isProgressMonitor() ? subTaskJava(monitor, title) : "";

cached String subTaskJava(Object monitor, String title) :
	JAVA extensions.Utils.subTask(org.eclipse.core.runtime.IProgressMonitor, java.lang.String);


cached String getAppSourcePath(String appName) :
    'src/modules/'.msconcat(appName).msconcat('/');

cached String getAppSourceLibPath(String appName) :
    getAppSourcePath(appName).msconcat('lib/').msconcat(appName).msconcat('/');

cached String getAppUploadPath(String appName) :
    'src/userdata/'.msconcat(appName).msconcat('/');

cached String getAppTestsPath(String appName) :
    'tests/';

