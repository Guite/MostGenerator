«IMPORT modulestudio»
«REM«IMPORT templates::zclassic::smallstuff»«ENDREM»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«REMEXTENSION org::eclipse::xtend::util::stdlib::io»«ENDREM»

«REM»Entry point for Doctrine entity classes«ENDREM»
«DEFINE Root FOR Application-»
    «EXPAND Root(this) FOREACH models.entities-»
«REM»    «EXPAND Root(this) FOREACH models.relations.typeSelect(ManyToManyRelationship)-»«ENDREM»
    «EXPAND business::Validator::BaseValidator-»
    «EXPAND business::Validator::ValidatorWrapper(this) FOREACH models.entities-»
«IF hasTrees()-»
«FOREACH getTreeEntities() AS treeEntity-»
«EXPAND entity::Extensions::ClosureClass FOR treeEntity-»
«ENDFOREACH-»
«ENDDEFINE»

«REM»creates a entity class file for every Entity instance«ENDREM»
«DEFINE Root(Application app) FOR Entity-»
«info("Generating entity classes for entity \"" + name.formatForDisplay() + "\"") -> ""-»
«IF !isInheriting()-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModelEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelEntityBaseImpl(app)»«ENDFILE»
«ENDIF-»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModelEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelEntityImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE ModelEntityBaseImpl(Application app) FOR Entity-»
«EXPAND Imports-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the base entity class for «name.formatForDisplay()» entities.
 *
«EXPAND entity::Extensions::ClassExtensions-»
«REM»«EXPAND ObjectExtensions-»«ENDREM»
«IF mappedSuperClass-»
 * @ORM\MappedSuperclass
«ELSE-»
 * @ORM\Entity(repositoryClass="«implClassModel('repository', '')»"«IF readOnly-», readOnly=true«ENDIF-»)
«ENDIF-»
«IF indexes.isEmpty-»
 * @ORM\Table(name="«fullEntityName()»")
«ELSE-»
 * @ORM\Table(name="«fullEntityName()»",
«IF hasNormalIndexes()-»
 *     indexes={
«EXPAND Index('Index') FOREACH getNormalIndexes() SEPARATOR ','-»
 *     }«IF hasUniqueIndexes()-»,«ENDIF-»
«ENDIF-»
«IF hasUniqueIndexes()-»
 *     uniqueConstraints={
«EXPAND Index('UniqueConstraint') FOREACH getUniqueIndexes() SEPARATOR ','-»
 *     }
«ENDIF-»
 * )
«ENDIF-»
«IF isTopSuperClass()-»
 * @ORM\InheritanceType("«getChildRelations().get(0).strategy.asConstant()»")
 * @ORM\DiscriminatorColumn(name="«getChildRelations().get(0).discriminatorColumn.formatForCode()»"«REM», type="string"«ENDREM»)
 * @ORM\DiscriminatorMap({«EXPAND DiscriminatorInfo FOREACH getChildRelations() SEPARATOR ", "-»})
«ENDIF-»
«IF changeTrackingPolicy != EntityChangeTrackingPolicy::DEFERRED_IMPLICIT-»
 * @ORM\ChangeTrackingPolicy("«changeTrackingPolicy.asConstant()»")
«ENDIF-»
 * @ORM\HasLifecycleCallbacks
 */
class «baseClassModelEntity()» extends Zikula_EntityAccess«IF hasNotifyPolicy()-» implements NotifyPropertyChanged«ENDIF-»
{
«EXPAND EntityInfo-»
}
«ENDDEFINE»

«DEFINE Imports FOR Entity-»
use Doctrine\ORM\Mapping as ORM;
«IF hasCollections()-»
use Doctrine\Common\Collections\ArrayCollection;
«ENDIF-»
«EXPAND entity::Extensions::Imports-»
«IF hasNotifyPolicy()-»
use Doctrine\Common\NotifyPropertyChanged,
    Doctrine\Common\PropertyChangedListener;
«ENDIF-»
«ENDDEFINE»

«DEFINE Index(String indexType) FOR EntityIndex-»
@ORM\«indexType.toFirstUpper()»(name="«name.formatForDB()»", columns={«EXPAND IndexField FOREACH items SEPARATOR ','»})
«ENDDEFINE»
«DEFINE IndexField FOR EntityIndexItem-»"«name.formatForDB()»"«ENDDEFINE»

«DEFINE DiscriminatorInfo FOR InheritanceRelationship-»
«LET getRelationAliasName(false) AS sourceAliasName-»
"«sourceAliasName»" = "«sourceAliasName.toFirstUpper()»"
«ENDLET-»
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE ModelEntityImpl(Application app) FOR Entity-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the concrete entity class for «name.formatForDisplay()» entities.
 */
class «implClassModelEntity()» extends «IF isInheriting()»«parentType().implClassModelEntity()»«ELSE»«baseClassModelEntity()»«ENDIF»
{
    // feel free to add your own methods here
}
«ENDDEFINE»


«DEFINE EntityInfo FOR Entity-»
    /**
     * @var string The tablename this object maps to
     */
    protected $_objectType = '«name.formatForCode()-»';

    /**
     * @var string The primary key field name
     */
«REM»TODO support composite keys (#21)«ENDREM»
    protected $_idField = '«name.formatForCode()-»';

    /**
     * @var «implClassModel('validator', '')» The validator for this entity
     */
    protected $_validator = null;

    /**
     * @var boolean Whether this entity supports unique slugs
     */
    protected $_hasUniqueSlug = false;
«IF hasNotifyPolicy()-»

    /**
     * @var array List of change notification listeners
     */
    protected $_propertyChangedListeners = array();
«ENDIF-»

«EXPAND entity::Property::PersistentProperty FOREACH fields.typeSelect(DerivedField)»
«EXPAND entity::Extensions::AdditionalProperties-»
«EXPAND entity::Association::Root(false) FOREACH incoming.typeSelect(JoinRelationship)»
«EXPAND entity::Association::Root(true) FOREACH outgoing.typeSelect(JoinRelationship)»
«EXPAND Constructor-»

«EXPAND FileHelper::GetterAndSetterMethods('_objectType', 'string', false, false, '')»
«EXPAND FileHelper::GetterAndSetterMethods('_idField', 'string', false, false, '')»
«EXPAND FileHelper::GetterAndSetterMethods('_validator', implClassModel('validator', ''), false, true, 'null')»
«EXPAND FileHelper::GetterAndSetterMethods('_hasUniqueSlug', 'boolean', false, false, '')»
«EXPAND PropertyChangedListener-»

«EXPAND entity::Property::FieldAccessor FOREACH fields.typeSelect(DerivedField)»
«EXPAND entity::Extensions::AdditionalAccessors-»
«EXPAND entity::Association::RelationAccessor(false) FOREACH incoming.typeSelect(JoinRelationship)»
«EXPAND entity::Association::RelationAccessor(true) FOREACH outgoing.typeSelect(JoinRelationship)»

«EXPAND EventListener::Root-»

    /**
     * Start validation and raise exception if invalid data is found.
     *
     * @return void.
     */
    public function validate()
    {
        $result = $this->_validator->validateAll();
        if (is_array($result)) {
            throw new Zikula_Exception($result['message'], $result['code'], $result['debugArray']);
        }
    }

«ENDDEFINE»

«DEFINE Constructor FOR Entity-»
    /**
     * Constructor.
     * Will not be called by Doctrine and can therefore be used
     * for own implementation purposes. It is also possible to add
     * arbitrary arguments as with every other class method.
     */

«EXPAND ConstructorImpl-»
«ENDDEFINE»

«DEFINE ConstructorImpl FOR Entity-»
«IF isIndexByTarget()-»
«LET incoming.select(e|e.isIndexed()) AS indexRelation-»
«LET getRelationAliasName(indexRelation, false) AS sourceAlias-»
«LET getRelationAliasName(indexRelation, true) AS targetAlias-»
«LET source.getIndexByField() AS indexBy-»
    public function __construct($«indexBy.formatForCode()», «indexRelation.source.implClassModelEntity()» $«sourceAlias.formatForCode»)«EXPAND entity::Extensions::ConstructorImplements-»
    {
        $this->«indexBy.formatForCode()» = $«indexBy.formatForCode()»;
        $this->«sourceAlias.formatForCode()» = $«sourceAlias.formatForCode()»;
        $«sourceAlias.formatForCode()»->add«targetAlias.formatForCodeCapital()»($this);
«ENDLET-»
«ENDLET-»
«ENDLET-»
«ENDLET-»
«ELSEIF isAggregated()-»
    public function __construct(«EXPAND ConstructorParametersAggregate FOREACH getAggregators() SEPARATOR ', '»)«EXPAND entity::Extensions::ConstructorImplements-»
    {
«EXPAND ConstructorAssignmentAggregate FOREACH getAggregators()-»
    }
«ELSE-»
    public function __construct()«EXPAND entity::Extensions::ConstructorImplements-»
    {
«ENDIF-»
        $this->_objectType = '«fullEntityName()»';
        $this->_validator = new «implClassModel('validator', '')»($this);
        $this->_hasUniqueSlug = «IF hasSluggableFields() && slugUnique»true«ELSE»false«ENDIF»;
«EXPAND entity::Association::InitCollections-»
    }
«ENDDEFINE»

«DEFINE ConstructorParametersAggregate FOR OneToManyRelationship-»
«LET source.getAggregateFields().get(0).getAggregateTargetField() AS targetField-»
$«getRelationAliasName(false)», $«targetField.name.formatForCode()»
«ENDLET-»
«ENDDEFINE-»
«DEFINE ConstructorAssignmentAggregate FOR OneToManyRelationship-»
«LET source.getAggregateFields().get(0).getAggregateTargetField() AS targetField-»
        $this->«getRelationAliasName(false)» = $«getRelationAliasName(false)»;
        $this->«targetField.name.formatForCode()» = $«targetField.name.formatForCode()»;
«ENDLET-»
«ENDDEFINE-»

«DEFINE PropertyChangedListener FOR Entity-»
«IF hasNotifyPolicy()-»

    /**
     * Adds a property change listener.
     *
     * @param PropertyChangedListener $listener The listener to be added
     */
    public function addPropertyChangedListener(PropertyChangedListener $listener)
    {
        $this->_propertyChangedListeners[] = $listener;
    }

    /**
     * Notify all registered listeners about a changed property.
     *
     * @param String $propName Name of property which has been changed
     * @param mixed  $oldValue The old property value
     * @param mixed  $newValue The new property value
     */
    protected function _onPropertyChanged($propName, $oldValue, $newValue)
    {
        if ($this->_propertyChangedListeners) {
            foreach ($this->_propertyChangedListeners as $listener) {
                $listener->propertyChanged($this, $propName, $oldValue, $newValue);
            }
        }
    }
«ENDIF-»
«ENDDEFINE»

«REM»creates a reference entity class file for every many-to-many relationship instance«ENDREM»
«REM»TODO: remove all the redundancies below... maybe with the PersistenceTransformer transformation...«ENDREM»
«DEFINE Root(Application app) FOR ManyToManyRelationship-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModelRefEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRefEntityBaseImpl(app)»«ENDFILE»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModelRefEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRefEntityImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE ModelRefEntityBaseImpl(Application app) FOR ManyToManyRelationship-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the reference entity class for the many to many relationship
 * between «source.name.formatForDisplay()» and «target.name.formatForDisplay()» entities.
 */
class «baseClassModelRefEntity()» extends Zikula_EntityAccess
{
    /**
     * Set table definition.
     * Define columns, indexes and other information about the table schema.
     *
     * @return void
     */
    public function setTableDefinition()
    {
        $this->setTableName('«app.prefix().msconcat("_").msconcat(source.name.formatForDB()).msconcat("_").msconcat(target.name.formatForDB())»');

        $this->hasColumn('«source.idField()»', 'integer', null, array(
                'type' => 'integer',
                'primary' => true
            )
        );

        $this->hasColumn('«target.idField()»', 'integer', null, array(
                'type' => 'integer',
                'primary' => true
            )
        );
    }
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE ModelRefEntityImpl(Application app) FOR ManyToManyRelationship-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the reference entity class for the many to many relationship
 * between «source.name.formatForDisplay()» and «target.name.formatForDisplay()» entities.
 */
class «implClassModelRefEntity()» extends «baseClassModelRefEntity()»
{
    // feel free to add your own methods here
}
«ENDDEFINE»

«DEFINE ObjectExtensions FOR Entity»
«REM»will be filled by Advices (Aspect Orientation)«ENDREM»
«ENDDEFINE»

