«IMPORT modulestudio»
«REM«IMPORT templates::zclassic::smallstuff»«ENDREM»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«REMEXTENSION org::eclipse::xtend::util::stdlib::io»«ENDREM»

«REM»Entry point for Doctrine entity classes«ENDREM»
«DEFINE Root FOR Application-»
    «EXPAND Root(this) FOREACH models.entities-»
«REM»    «EXPAND Root(this) FOREACH models.relations.typeSelect(ManyToManyRelationship)-»«ENDREM»
    «EXPAND business::Validator::BusinessValidatorWrapper(this) FOREACH models.entities-»
«ENDDEFINE»

«REM»creates a entity class file for every Entity instance«ENDREM»
«DEFINE Root(Application app) FOR Entity-»
«info("Generating entity classes for entity \"" + name.formatForDisplay() + "\"") -> ""-»
«IF !isInheriting()-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModelEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelEntityBaseImpl(app)»«ENDFILE»
«ENDIF-»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModelEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelEntityImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE ModelEntityBaseImpl(Application app) FOR Entity-»
«EXPAND Imports-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the base entity class for «name.formatForDisplay()» entities.
 *
«EXPAND entity::Extensions::ClassExtensions-»
 * @ORM\Entity(repositoryClass="«implClassModelRepository()»"«IF readOnly-», readOnly=true«ENDIF-»)
«IF indexes.isEmpty-»
 * @ORM\Table(name="«fullEntityName()»")
«ELSE-»
 * @ORM\Table(name="«fullEntityName()»",
«IF hasNormalIndexes()-»
 *      indexes={«EXPAND Index('Index') FOREACH getNormalIndexes() SEPARATOR ','-»}«IF hasUniqueIndexes()-»,«ENDIF-»
«ENDIF-»
«IF hasUniqueIndexes()-»
 *      uniqueConstraints={«EXPAND Index('UniqueConstraint') FOREACH getUniqueIndexes() SEPARATOR ','-»}
«ENDIF-»
 * )
«ENDIF-»
«REM»TODO: change tracking policy is not per-class, but per-class-hierarchy«ENDREM»
«IF changeTrackingPolicy != EntityChangeTrackingPolicy::DEFERRED_IMPLICIT-»
 * @ORM\ChangeTrackingPolicy("«changeTrackingPolicy.asConstant()»")
«ENDIF-»

 */
class «baseClassModelEntity()» extends Zikula_EntityAccess«IF hasNotifyPolicy()-» implements NotifyPropertyChanged«ENDIF-»
{
«EXPAND EntityInfo-»
}
«ENDDEFINE»

«DEFINE Imports FOR Entity-»
use Doctrine\ORM\Mapping as ORM;
«IF hasCollections()-»
use Doctrine\Common\Collections\ArrayCollection;
«ENDIF-»
«EXPAND entity::Extensions::Imports-»
«IF hasNotifyPolicy()-»
use Doctrine\Common\NotifyPropertyChanged,
    Doctrine\Common\PropertyChangedListener;
«ENDIF-»
«ENDDEFINE»

«DEFINE Index(String indexType) FOR EntityIndex-»
@ORM\«indexType.toFirstUpper()»(name="«name.formatForDB()»", columns={«EXPAND IndexField FOREACH items SEPARATOR ','»})
«ENDDEFINE»
«DEFINE IndexField FOR EntityIndexItem-»"«name.formatForDB()»"«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE ModelEntityImpl(Application app) FOR Entity-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the concrete entity class for «name.formatForDisplay()» entities.
 */
class «implClassModelEntity()» extends «IF isInheriting()»«parentType().implClassModelEntity()»«ELSE»«baseClassModelEntity()»«ENDIF»
{
    // feel free to add your own methods here
}
«ENDDEFINE»


«DEFINE EntityInfo FOR Entity-»
    /**
     * @var string The tablename this object maps to
     */
    protected $_objectType = '«name.formatForCode()-»';

    /**
     * @var string The primary key field name
     */
«REM»TODO support composite keys«ENDREM»
    protected $_idField = '«name.formatForCode()-»';

    /**
     * @var «implClassBusinessValidator()» The validator for this entity
     */
    protected $_validator = null;

    /**
     * @var boolean Whether this entity supports unique slugs
     */
    protected $_hasUniqueSlug = false;
«IF hasNotifyPolicy()-»

    /**
     * @var array List of change notification listeners
     */
    protected $_propertyChangedListeners = array();
«ENDIF-»

«EXPAND entity::Property::PersistentProperty FOREACH fields.typeSelect(DerivedField)»
«EXPAND entity::Extensions::AdditionalProperties-»
«EXPAND entity::Association::Root(false) FOREACH incoming.typeSelect(JoinRelationship)»
«EXPAND entity::Association::Root(true) FOREACH outgoing.typeSelect(JoinRelationship)»

    /**
     * Constructor.
     * Will not be called by Doctrine and can therefore be used
     * for own implementation purposes. It is also possible to add
     * arbitrary arguments as with every other class method.
     */
    public function __construct()
    {
«EXPAND entity::Association::InitCollections-»
    }

«EXPAND FileHelper::GetterAndSetterMethods('_objectType', 'string')»
«EXPAND FileHelper::GetterAndSetterMethods('_idField', 'string')»
«EXPAND FileHelper::GetterAndSetterMethods('_validator', implClassBusinessValidator())»
«EXPAND FileHelper::GetterAndSetterMethods('_hasUniqueSlug', 'boolean')»
«IF hasNotifyPolicy()-»

    /**
     * Adds a property change listener.
     *
     * @param PropertyChangedListener $listener The listener to be added
     */
    public function addPropertyChangedListener(PropertyChangedListener $listener)
    {
        $this->_propertyChangedListeners[] = $listener;
    }

    /**
     * Notify all registered listeners about a changed property.
     *
     * @param String $propName Name of property which has been changed
     * @param mixed  $oldValue The old property value
     * @param mixed  $newValue The new property value
     */
    protected function _onPropertyChanged($propName, $oldValue, $newValue)
    {
        if ($this->_propertyChangedListeners) {
            foreach ($this->_propertyChangedListeners as $listener) {
                $listener->propertyChanged($this, $propName, $oldValue, $newValue);
            }
        }
    }
«ENDIF-»
«ENDREM»

«EXPAND entity::Property::FieldAccessor FOREACH fields.typeSelect(DerivedField)»
«EXPAND entity::Association::RelationAccessor(false) FOREACH incoming.typeSelect(JoinRelationship)»
«EXPAND entity::Association::RelationAccessor(true) FOREACH outgoing.typeSelect(JoinRelationship)»

«ENDDEFINE»




«REM»
«IF isInheriter()-»
«EXPAND SubClasses-»
«ENDIF-»
«EXPAND SetUpBehaviour»
«ENDREM»



«DEFINE OLDBaseImpl(Application app) FOR Entity»
    /**
     * Constructor.
     *
     * @param integer $id The id to use to retrieve the object (optional) (default=null).
     */
    public function __construct($id = 0)
    {
        $this->_objectType = '«fullEntityName()»';
        $this->_validator = new «implClassBusinessValidator()»($this);
        $this->_hasUniqueSlug = «IF hasSluggableFields() && slugUnique»true«ELSE»false«ENDIF»;
    }

    /**
     * Select object from model (e.g. from database).
     * For now we use Doctrine records, but as the controllers communicate only with
     * business entities, we can exchange the model behind it without any subsequent
     * efforts on the controller layer.
     *
     * @param integer $id      The id to use to retrieve the object (optional) (default=null).
     * @param boolean $asArray Whether to return the result as array instead as record object (optional) (default=true).
     *
     * @return array|Doctrine_Record Retrieved data array or Doctrine_Record instance.
     */
    public function selectById($id = 0, $asArray = true)
    {
        // check id parameter
        if ($id == 0 && $this->_id == 0) {
            return LogUtil::registerArgsError();
        }
        // store id parameter
        if ($id > 0) {
            $this->_id = $id;
        }

        $entityClass = '«implClassModelEntity()»';
        $repository = $this->entityManager->getRepository($entityClass);

        // get result from the model
        $item = $repository->selectOneItemById($id, $asArray);

«IF hasTranslatableFields()-»
        // process translations
        $item = «app.appName()»_Util_I18n::prepareEntityForOutput('«name.formatForCode()»', $item);

«ENDIF-»

        // return the results
        return $item;
    }
«IF sluggable && sluggableUnique-»

    /**
     * Select object by unique slug value.
     *
     * @param string  $slugTitle The slug value.
     * @param boolean $asArray   Whether to return the result as array instead as record object (optional) (default=true).
     *
     * @return array|Doctrine_Record retrieved data array or Doctrine_Record instance.
     */
    public function selectBySlug($slugTitle = '', $asArray = true)
    {
        // check input parameter
        if ($slugTitle == '') {
            return LogUtil::registerArgsError();
        }

        $entityClass = '«implClassModelEntity()»';
        $repository = $this->entityManager->getRepository($entityClass);

        // get result from the model
        $item = $repository->selectOneItemBySlug($slugTitle, $asArray);

«IF hasTranslatableFields()-»
        // process translations
        $item = «app.appName()»_Util_I18n::prepareEntityForOutput('«name.formatForCode()»', $item);

«ENDIF-»
        // return the results
        return $item;
    }
«ENDIF-»

«ENDDEFINE»


«DEFINE SubClasses FOR Entity-»
«LET getChildRelationsWithAggregation() AS aggregatedChildren-»
«IF !aggregatedChildren.isEmpty-»
        $this->setSubclasses(array(
«EXPAND SubClass FOREACH aggregatedChildren-»
            )
        );
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«DEFINE SubClass FOR InheritanceRelationship-»
                '«source.name.formatForCode()»' => array('«columnAggregationField.formatForCode()»' => '«source.name.formatForCode()»')
«ENDDEFINE»






«DEFINE OLDCollectionBaseImpl(Application app) FOR Entity»

    /**
     * @var string Optional where clause for selection.
     */
    protected $_where = '';

    /**
     * @var string Optional order clause for selection.
     */
    protected $_orderBy = '';

    /**
     * @var string The default sorting field/expression.
     */
    protected $_defaultSortingField = '«getLeadingField().name.formatForCode()»';


    /**
     * Constructor.
     *
     * @param string $where   The where clause to use when retrieving the object array (optional) (default='').
     * @param string $orderBy The order-by clause to use when retrieving the object array (optional) (default='').
     */
    function __construct($where = '', $orderBy = '')
    {
        $this->set_intWhere($where);
        $this->set_intOrderBy($orderBy);
    }

    /**
     * Select object collection from model (e.g. from database).
     *
     * For now we use Doctrine records, but as the controllers communicate only with
     * business entities, we can exchange the model behind it without any subsequent
     * efforts on the controller layer.
     *
     * @param string $where    The where clause to use when retrieving the object array (optional) (default='').
     * @param string $orderBy  The order-by clause to use when retrieving the object array (optional) (default='').
     * @param boolean $asArray Whether to return the result as array instead as record object (optional) (default=true).
     *
     * @return Doctrine_Collection collection containing retrieved Doctrine_Record instances
     */
    public function selectWhere($where = '', $orderBy = '', $asArray = true)
    {
        // store parameters
        $this->set_intWhere($where);
        $this->set_intOrderBy($orderBy);

        // select items from the model
        $result = $this->_intTable()->selectCollection($where, $orderBy, $asArray);

«IF hasTranslatableFields()-»
        // process additions
        $result = $this->processAdditions($result);

«ENDIF-»
        // store the results
        $this->set«nameMultiple.formatForCodeCapital()»($result);

        // and return them
        return $this->get«nameMultiple.formatForCodeCapital()»();
    }

    /**
     * Select with a given where clause.
     *
     * @param string $where           The where clause to use when retrieving the object array (optional) (default='').
     * @param string $orderBy         The order-by clause to use when retrieving the object array (optional) (default='').
     * @param integer $currentPage    Where to start selection
     * @param integer $resultsPerPage Amount of items to select
     * @param boolean $asArray        Whether to return the result as array instead as record object (optional) (default=true).
     *
     * @return array                  Array with retrieved data and amount of total records affected by this query.
     */
    public function selectWherePaginated($where = '', $orderBy = '', $currentPage = 1, $resultsPerPage = 25, $asArray = true)
    {
        // store parameters
        $this->set_intWhere($where);
        $this->set_intOrderBy($orderBy);

        // select items from the model
        list($objectData, $objectCount) = $this->_intTable()->selectWherePaginated($where, $orderBy, $currentPage, $resultsPerPage, $asArray);

«IF hasTranslatableFields()-»
        // process additions
        $objectData = $this->processAdditions($objectData);

«ENDIF-»
        // store the results
        $this->set«nameMultiple.formatForCodeCapital()»($objectData);

        // and return them
        return array($this->get«nameMultiple.formatForCodeCapital()»(), $objectCount);
    }

    /**
     * Select count with a given where clause.
     *
     * @param string $where The where clause to use when retrieving the object count (optional) (default='').
     *
     * @return integer Number of affected records.
     */
    public function selectCount($where = '')
    {
        // store parameters
        $this->set_intWhere($where);

        // get result from the model
        return $this->_intTable()->selectCount($where);
    }
«IF tree != EntityTreeType::NONE-»

    /**
     * Select tree of «nameMultiple.formatForCode()».
     *
«REM»«IF nestedSetHasManyRoots-»«ENDREM»
     * @param integer $rootId         Optional id of root node to use as a branch, defaults to 0 which corresponds to the whole tree.
«REM»«ENDIF-»«ENDREM»
     * @param boolean $asArray        Whether to return the result as array instead as record object (optional) (default=true).
     *
     * @return array|Doctrine_Doctrine_Tree_NestedSet retrieved data array or tree objects containing retrieved Doctrine_Node_NestedSet instances.
     */
    public function selectTree(«REM»«IF nestedSetHasManyRoots-»«ENDREM»$rootId = 0, «REM»«ENDIF»«ENDREM»$asArray = false)
    {
        // get result from the model
        $tree = $this->_intTable()->selectTree(«REM»«IF nestedSetHasManyRoots-»«ENDREM»$rootId, «REM»«ENDIF»«ENDREM»$asArray);
«IF hasTranslatableFields()-»

        // process additions
        $tree = $this->processAdditions($tree);
«ENDIF-»

        return $tree;
    }

«REM»«IF nestedSetHasManyRoots-»«ENDREM»

    /**
     * Select all trees at once.
     *
     * @param boolean $asArray        Whether to return the result as array instead as record object (optional) (default=true).
     *
     * @return array list of retrieved data arrays or tree objects containing retrieved Doctrine_Node_NestedSet instances.
     */
    public function selectAllTrees($asArray = false)
    {
        // get result from the model
        $trees = $this->_intTable()->selectAllTrees($asArray);
«IF hasTranslatableFields()-»

        // process additions
        foreach ($trees as $rootId => $treeNodes) {
            $trees[$rootId] = $this->processAdditions($treeNodes);
        }
«ENDIF-»

        return $trees;
    }
«REM»«ENDIF-»«ENDREM»

    /**
     * Get tree object for managing the nested set.
     *
     * @return Doctrine_Doctrine_Tree_NestedSet tree object reference.
     */
    public function getTreeObject()
    {
        return $this->_intTable()->getTree();
    }
«ENDIF-»
«IF hasTranslatableFields()-»

    /**
     * Process custom additions.
     */
    protected function processAdditions($collection)
    {
        if (!$collection) {
            return $collection;
        }
        foreach ($collection as $k => $v) {
            $collection[$k] = «app.appName()»_Util_I18n::prepareEntityForOutput('«name.formatForCode()»', $v);
        }
        return $collection;
    }
«ENDIF-»

    /**
     * Convenience method to get table managed by record.
     *
     * @return Doctrine_Table Table being managed by the record referenced by this collection.
     */
    private function _intTable()
    {
        return Doctrine_Core::getTable('«implClassModelRecord()»');
    }

    /**
     * Retrieves an array with all fields which can be used for sorting instances.
     *
     * @return array
     */
    public function get_allowedSortingFields()
    {
        // TODO: to be refactored
        return array(«EXPAND singleSortingField FOREACH fields SEPARATOR ','»«EXPAND standardSortingFields FOR this-»
        );
    }

«EXPAND FileHelper::GetterAndSetterMethods('_where', 'string')»
«EXPAND FileHelper::GetterAndSetterMethods('_orderBy', 'string')»
«EXPAND FileHelper::GetterAndSetterMethods('_defaultSortingField', 'string')»

«ENDDEFINE»

«DEFINE singleSortingField FOR EntityField»«REM»DUMMY«ENDREM»«ENDDEFINE»
«DEFINE singleSortingField FOR DerivedField»
«LET entity.incoming.select(e|formatForDB(e.source.idField()) == name.formatForDB()) AS joins-»
«IF !joins.isEmpty-»
                     '«joins.get(0).source.name.formatForCode()»'«""-»
«ELSE-»
                     '«name.formatForCode()»'«""-»
«ENDIF-»
«ENDLET-»«ENDDEFINE»
«DEFINE singleSortingField FOR CalculatedField»
                     '«name.formatForCode()»'«""-»
«ENDDEFINE»

«DEFINE standardSortingFields FOR Entity»
«REM»will be filled by Advices (Aspect Orientation)«ENDREM»
«ENDDEFINE»



























«REM»creates a reference entity class file for every many-to-many relationship instance«ENDREM»
«REM»TODO: remove all the redundancies below... maybe with the PersistenceTransformer transformation...«ENDREM»
«DEFINE Root(Application app) FOR ManyToManyRelationship-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModelRefEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRefEntityBaseImpl(app)»«ENDFILE»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModelRefEntity().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRefEntityImpl(app)»«ENDFILE»
«ENDDEFINE»


«REM»base implementation«ENDREM»
«DEFINE ModelRefEntityBaseImpl(Application app) FOR ManyToManyRelationship-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the reference entity class for the many to many relationship
 * between «source.name.formatForDisplay()» and «target.name.formatForDisplay()» entities.
 */
class «baseClassModelRefEntity()» extends Doctrine_Entity
{
    /**
     * Set table definition.
     * Define columns, indexes and other information about the table schema.
     *
     * @return void
     */
    public function setTableDefinition()
    {
        $this->setTableName('«app.prefix().msconcat("_").msconcat(source.name.formatForDB()).msconcat("_").msconcat(target.name.formatForDB())»');

        $this->hasColumn('«source.idField()»', 'integer', null, array(
                'type' => 'integer',
                'primary' => true
            )
        );

        $this->hasColumn('«target.idField()»', 'integer', null, array(
                'type' => 'integer',
                'primary' => true
            )
        );
    }
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE ModelRefEntityImpl(Application app) FOR ManyToManyRelationship-»

/**
 * Entity class that defines the entity structure and behaviours.
 *
 * This is the reference entity class for the many to many relationship
 * between «source.name.formatForDisplay()» and «target.name.formatForDisplay()» entities.
 */
class «implClassModelRefEntity()» extends «baseClassModelRefEntity()»
{
    // feel free to add your own methods here
}
«ENDDEFINE»










«DEFINE SetUpBehaviour FOR Entity-»
«IF hasTranslatableFields()-»
        // Internationalisation (content in multiple language)
        // See http://code.zikula.org/core/ticket/2401 for possible future support in the Zikula core
        $i18n = new Doctrine_Template_I18n(array(
                'className' => '%CLASS%Translation',
                'fields'    => array('«i18nFields.replaceAll(", ", "', '")»'),
                'type'      => 'string',
                'length'    => 2
            )
        );

        $this->actAs($i18n);
«ENDIF-»

«IF tree != EntityTreeType::NONE-»
        // Tree for hierarchical data structures
        $this->actAs('NestedSet', array(
                'hasManyRoots' => «nestedSetHasManyRoots.displayBool()»,
                'rootColumnName' => '«nestedSetRootField.formatForDB()»'
            )
        );
«ENDIF-»
«IF geographical-»
        // Coordinate fields and distance calculation
        // See http://code.zikula.org/core/ticket/2401 for possible future support in the Zikula core
        // $this->actAs('Geographical');

        // Workaround for wrong scaling (Doctrine bug)
        // See http://www.tkstudios.com/2010/04/27/fixing-doctrines-geographical-template-precision/
        $geographical0 = new Doctrine_Template_Geographical(array(
           'latitude' => array(
              'options' => array(
                 'scale' => 7,
              ),
           ),
           'longitude' => array(
              'options' => array(
                 'scale' => 7,
              ),
           ),
        ));
        $this->actAs($geographical0);
«ENDIF-»

«EXPAND ObjectExtensions-»

        /**
         * Event listeners registrations
         */
        $this->addListener(new «implClassModelListener()»());
«ENDDEFINE»

«DEFINE ObjectExtensions FOR Entity»
«REM»will be filled by Advices (Aspect Orientation)«ENDREM»
«ENDDEFINE»






