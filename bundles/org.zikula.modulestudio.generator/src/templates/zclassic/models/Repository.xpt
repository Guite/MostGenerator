«IMPORT modulestudio»
«REM«IMPORT templates::zclassic::smallstuff»«ENDREM»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«REMEXTENSION org::eclipse::xtend::util::stdlib::io»«ENDREM»

«REM»Entry point for Doctrine table classes«ENDREM»
«DEFINE Root FOR Application-»
    «EXPAND Root(this) FOREACH models.entities-»
    «EXPAND Root(this) FOREACH models.relations.typeSelect(ManyToManyRelationship)-»
«ENDDEFINE»

«REM»creates a repository class file for every Entity instance«ENDREM»
«DEFINE Root(Application app) FOR Entity-»
«info("Generating repository classes for entity \"" + name.formatForDisplay() + "\"") -> ""-»
«IF !isInheriting()-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModelRepository().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRepositoryBaseImpl(app)»«ENDFILE»
«ENDIF-»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModelRepository().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRepositoryImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE ModelRepositoryBaseImpl(Application app) FOR Entity-»

«IF tree != EntityTreeType::NONE-»
use Gedmo\Tree\Entity\Repository\«tree.asConstant().toFirstUpper()»TreeRepository;
«ELSE-»
use Doctrine\ORM\EntityRepository;
«ENDIF-»

/**
 * Repository class used to implement own convenience methods for performing certain DQL queries.
 *
 * This is the base repository class for «name.formatForDisplay()» entities.
 */
class «baseClassModelRepository()» extends «IF tree != EntityTreeType::NONE-»«tree.asConstant().toFirstUpper()»TreeRepository«ELSE-»EntityRepository«ENDIF-»
{
    /**
     * Hook into the constructor process.
     */
    public function construct()
    {
    }

    /**
     * Helper method for truncating the table.
     * Used during installation when inserting default data.
     */
    public function truncateTable()
    {
        $q = $this->getEntityManager()
            ->createQuery('DELETE «implClassModelEntity()»');
        $q->execute();
    }

    /**
     * Select object from the database.
     *
     * @param integer $id       The id to use to retrieve the object (optional) (default=null).
     * @param boolean $asArray  Whether to return the result as array instead as record object (optional) (default=true).
     * @param boolean $useJoins Whether to include joining related objects (optional) (default=true).
     *
     * @return array|«implClassModelEntity()» retrieved data array or «implClassModelEntity()» instance
     */
    public function selectOneItemById($id = 0, $asArray = true, $useJoins = true)
    {
        $q = $this->_intBaseQuery('', '', $useJoins)
                  ->where('tbl.«idField()» = ?', $id);

        $fetchType = (($asArray) ? Doctrine_Core::HYDRATE_ARRAY : Doctrine_Core::HYDRATE_RECORD);
        return $q->fetchOne(array(), $fetchType);
    }

«IF sluggable && sluggableUnique-»

    /**
     * Select object by slug field
     *
     * @param string  $slugTitle The slug value
     * @param boolean $asArray   Whether to return the result as array instead as record object (optional) (default=true).
     * @param boolean $useJoins  Whether to include joining related objects (optional) (default=true).
     *
     * @return array|«implClassModelEntity()» retrieved data array or «implClassModelEntity()» instance
     */
    public function selectOneItemBy«((sluggableFieldAlias != null && sluggableFieldAlias != "") ? sluggableFieldAlias : sluggableFieldName).formatForCodeCapital()»($slugTitle = '', $asArray = true, $useJoins = true)
    {
        $q = $this->_intBaseQuery('', '', $useJoins)
                  ->where('tbl.«((sluggableFieldAlias != null && sluggableFieldAlias != "") ? sluggableFieldAlias : sluggableFieldName).formatForCode()» = ?', $slugTitle);

        $fetchType = (($asArray) ? Doctrine_Core::HYDRATE_ARRAY : Doctrine_Core::HYDRATE_RECORD);
        return $q->fetchOne(array(), $fetchType);
    }
«ENDIF-»

    /**
     * Select a collection.
     *
     * @param string $where     The where clause to use when retrieving the object array (optional) (default='').
     * @param string $orderBy   The order-by clause to use when retrieving the object array (optional) (default='').
     * @param boolean $asArray  Whether to return the result as array instead as record object (optional) (default=true).
     * @param boolean $useJoins Whether to include joining related objects (optional) (default=true).
     *
     * @return array|Doctrine_Collection retrieved data array or collection containing retrieved «implClassModelEntity()» instances
     */
    public function selectCollection($where = '', $orderBy = '', $asArray = true, $useJoins = true)
    {
        $q = $this->_intBaseQuery($where, $orderBy, $useJoins);
        $fetchType = (($asArray) ? Doctrine_Core::HYDRATE_ARRAY : Doctrine_Core::HYDRATE_RECORD);
        return $q->execute(array(), $fetchType);
    }

    /**
     * Select with a given where clause.
     *
     * @param string $where           The where clause to use when retrieving the object array (optional) (default='').
     * @param string $orderBy         The order-by clause to use when retrieving the object array (optional) (default='').
     * @param integer $currentPage    Where to start selection
     * @param integer $resultsPerPage Amount of items to select
     * @param boolean $asArray        Whether to return the result as array instead as record object (optional) (default=true).
     * @param boolean $useJoins       Whether to include joining related objects (optional) (default=true).
     *
     * @return array Array with retrieved data and amount of total records affected by this query.
     */
    public function selectWherePaginated($where = '', $orderBy = '', $currentPage = 1, $resultsPerPage = 25, $asArray = true, $useJoins = true)
    {
        /*$q = $this->_intBaseQuery($where, $orderBy, $useJoins)
             ->setMaxResults($resultsPerPage);*/
        $pager = new Doctrine_Pager(
              $this->_intBaseQuery($where, $orderBy, $useJoins),
              $currentPage,
              $resultsPerPage
        );

        $fetchType = (($asArray) ? Doctrine_Core::HYDRATE_ARRAY : Doctrine_Core::HYDRATE_RECORD);
        $results = $pager->execute(array(), $fetchType);
        $count = $pager->getNumResults();
        return array($results, $count);
    }
«IF !getUniqueDerivedFields().isEmpty-»

    /**
     * Select count with a given where clause.
     *
     * @param string  $where    The where clause to use when retrieving the object count (optional) (default='').
     * @param boolean $useJoins Whether to include joining related objects (optional) (default=true).
     *
     * @return integer amount of affected records
     */
    public function selectCount($where = '', $useJoins = true)
    {
        // TODO: fix usage of joins; please remove the following line and test.
        $useJoins = false;

        $selection = 'COUNT(tbl.«idField()») AS num«nameMultiple.formatForCodeCapital()»';
        if ($useJoins === true) {
            $selection = $this->addJoinsToSelection($selection);
        }

        $q = Doctrine_Query::create()
            ->select($selection)
            ->from('«implClassModelRecord()» tbl');

        if ($useJoins === true) {
            $this->addJoinsToFrom($q);
        }

        if (!empty($where)) {
            $q->where($where);
        }
        return $q->fetchOne(array(), Doctrine_Core::HYDRATE_SINGLE_SCALAR);
    }
«ENDIF-»

«REM»
    public function getAllAdminUsers()
    {
        return $this->getEntityManager()
                    ->createQuery('SELECT u FROM MyDomain\Model\User u WHERE u.status = "admin"')
                    ->getResult();

        // All users with an age between 20 and 30 (inclusive).
        $q = $em->createQuery("select u from MyDomain\Model\User u where u.age >= 20 and u.age <= 30");
        $users = $q->getResult();
    }

    public function getRecentBugs($number = 30)
    {
        $dql = "SELECT b, e, r FROM Bug b JOIN b.engineer e JOIN b.reporter r ORDER BY b.created DESC";

        $query = $this->getEntityManager()->createQuery($dql);
        $query->setMaxResults($number);
        return $query->getResult();
    }

    public function getRecentBugsArray($number = 30)
    {
        $dql = "SELECT b, e, r, p FROM Bug b JOIN b.engineer e ".
               "JOIN b.reporter r JOIN b.products p ORDER BY b.created DESC";
        $query = $this->getEntityManager()->createQuery($dql);
        $query->setMaxResults($number);
        return $query->getArrayResult();
    }

    public function getUsersBugs($userId, $number = 15)
    {
        $dql = "SELECT b, e, r FROM Bug b JOIN b.engineer e JOIN b.reporter r ".
               "WHERE b.status = 'OPEN' AND e.id = ?1 OR r.id = ?1 ORDER BY b.created DESC";

        return $this->getEntityManager()->createQuery($dql)
                             ->setParameter(1, $userId)
                             ->setMaxResults($number)
                             ->getResult();
    }


For extending find(), findOneBy() or findBy() one must follow the
interface Doctrine\Common\Persistence\ObjectRepository.

    /**
     * Finds an object by its primary key / identifier.
     *
     * @param $id The identifier.
     * @return object The object.
     */
    public function find($id);

    /**
     * Finds all objects in the repository.
     *
     * @return mixed The objects.
     */
    public function findAll();

    /**
     * Finds objects by a set of criteria.
     *
     * Optionally sorting and limiting details can be passed. An implementation may throw
     * an UnexpectedValueException if certain values of the sorting or limiting details are
     * not supported.
     *
     * @throws UnexpectedValueException
     * @param array $criteria
     * @param array|null $orderBy
     * @param int|null $limit
     * @param int|null $offset
     * @return mixed The objects.
     */
    public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null);

    /**
     * Finds a single object by a set of criteria.
     *
     * @param array $criteria
     * @return object The object.
     */
    public function findOneBy(array $criteria);

«ENDREM»


«EXPAND TreeMethods(app)-»

    /**
     * Build a generic Doctrine query supporting WHERE and ORDER BY
     *
     * @param string  $where    The where clause to use when retrieving the object array (optional) (default='').
     * @param string  $orderBy  The order-by clause to use when retrieving the object array (optional) (default='').
     * @param boolean $useJoins Whether to include joining related objects (optional) (default=true).
     *
     * @return Doctrine_Query query instance to be further processed
     */
    protected function _intBaseQuery($where = '', $orderBy = '', $useJoins = true)
    {
        $selection = 'tbl.*' . (($orderBy == 'RAND()') ? ', RANDOM() rand' : '');
        if ($useJoins === true) {
            $selection = $this->addJoinsToSelection($selection);
        }

        // create base selection query
        $q = $this->getEntityManager()->createQuery()
            ->select($selection)
            ->from('«implClassModelRecord()» tbl');

        // add join information
        if ($useJoins === true) {
            $this->addJoinsToFrom($q);
        }

        if (!empty($where)) {
            $q->where('tbl.' . $where);
        }

        // use FilterUtil to support generic filtering
        $fu = new FilterUtil('«container.application.appName()»', $this);

        // you could set explicit filters at this point, something like
        // $fu->setFilter('type:eq:' . $args['type'] . ',id:eq:' . $args['id']);
        // supported operators: eq, ne, like, lt, le, gt, ge, null, notnull

        // process request input filters and add them to the query.
        $fu->enrichQuery($q);

«IF hasTranslatableFields()-»

        $currentFunc = FormUtil::getPassedValue('func', 'main', 'GETPOST', FILTER_SANITIZE_STRING);
        if ($useJoins == true && $currentFunc != 'edit') {
            if (!empty($where)) {
                $q->andWhere('Translation.lang = ?', array(ZLanguage::getLanguageCode()));
            }
            else {
                $q->where('Translation.lang = ?', array(ZLanguage::getLanguageCode()));
            }
        }
«ENDIF-»
        // add order by clause
        if (!empty($orderBy)) {
            if ($orderBy == 'RAND()') {
                $q->orderBy('rand');
            }
            else {
«IF hasTranslatableFields()-»
                // HACK FOR Translatable behavior
                $sortParts = explode(' ', $orderBy);
                $sortField = $sortParts[0];
                if (in_array($sortField, array(«EXPAND TranslationArrayPart FOREACH getTranslatableFields() SEPARATOR ', '-»))) {
                    $q->orderBy('Translation.' . $orderBy);
                }
                else {
                    $q->orderBy('tbl.' . $orderBy);
                }
«ELSE-»
                $q->orderBy('tbl.' . $orderBy);
«ENDIF-»
            }
        }
        return $q;
    }
«EXPAND JoinMethods(app)-»
}
«ENDDEFINE»

«DEFINE TranslationArrayPart FOR DerivedField-»'«name.formatForCode()-»'«ENDDEFINE»

«DEFINE TreeMethods(Application app) FOR Entity-»
«IF tree != EntityTreeType::NONE-»

    /**
     * Select tree of «nameMultiple.formatForCode()».
     *
     * @param integer $rootId   Optional id of root node to use as a branch, defaults to 0 which corresponds to the whole tree.
     * @param boolean $asArray  Whether to return the result as array instead as record object (optional) (default=true).
     * @param boolean $useJoins Whether to include joining related objects (optional) (default=true).
     *
     * @return array|Doctrine_Doctrine_Tree_NestedSet retrieved data array or tree objects containing retrieved Doctrine_Node_NestedSet instances.
     */
    public function selectTree($rootId = 0, $asArray = false, $useJoins = true)
    {
        // get reference to tree object
        $treeObject = $this->getTree();
        if ($useJoins === true) {
            $treeObject->setBaseQuery($this->_intBaseQuery());
            // note that this query modification can also be used for all node and tree methods (like getAncestors(), getDescendants(), getChildren(), getParent(), and so on)
        }

        $fetchType = (($asArray) ? Doctrine_Core::HYDRATE_ARRAY : Doctrine_Core::HYDRATE_RECORD);
        $result = null;

        // return branch if we have given a certain root
        if ($rootId > 0) {
            $root = $treeObject->fetchRoot($rootId);
            if (!$root) {
                // abort if no root node has been created yet
                return false;
            }
            $result = $treeObject->fetchBranch($root->«idField()», array(), $fetchType);
        }
        else {
            // otherwise return the whole tree
            $result = $treeObject->fetchTree(array(), $fetchType);
        }

        if ($useJoins === true) {
            $treeObject->resetBaseQuery();
        }

        return $result;
    }

    /**
     * Select all trees at once.
     *
     * @param boolean $asArray  Whether to return the result as array instead as record object (optional) (default=true).
     * @param boolean $useJoins Whether to include joining related objects (optional) (default=true).
     *
     * @return array list of retrieved data arrays or tree objects containing retrieved Doctrine_Node_NestedSet instances.
     */
    public function selectAllTrees($asArray = false, $useJoins = true)
    {
        $trees = array();
        $treeObject = $this->getTree();
        if ($useJoins === true) {
            $treeObject->setBaseQuery($this->_intBaseQuery());
            // note that this query modification can also be used for all node and tree methods (like getAncestors(), getDescendants(), getChildren(), getParent(), and so on)
        }

        $rootColumnName = $treeObject->getAttribute('rootColumnName');
        $fetchType = (($asArray) ? Doctrine_Core::HYDRATE_ARRAY : Doctrine_Core::HYDRATE_RECORD);

        foreach ($treeObject->fetchRoots() as $rootNode) {
            $options = array('root_id' => $rootNode->$rootColumnName);
            $trees[$rootNode->$rootColumnName] = $treeObject->fetchTree($options, $fetchType);
        }

        if ($useJoins === true) {
            $treeObject->resetBaseQuery();
        }

        return $trees;
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE JoinMethods(Application app) FOR Entity-»

    /**
     * Helper method to add join selections.
     *
     * @param String $selection Input select string to be enhanced.
     */
    protected function addJoinsToSelection($selection)
    {
«IF hasTranslatableFields()-»
        $selection .= ', Translation.*';
«ENDIF-»
        $selection .= '«EXPAND AddJoin(false, 'select') FOREACH incoming.typeSelect(JoinRelationship)-»«EXPAND AddJoin(true, 'select') FOREACH outgoing.typeSelect(JoinRelationship)-»';
        return $selection;
    }

    /**
     * Helper method to add joins to from clause.
     *
     * @param Doctrine_Query $q Reference to query to be enriched.
     */
    protected function addJoinsToFrom(Doctrine_Query $q)
    {
«IF hasTranslatableFields()-»
        $q->leftJoin('tbl.Translation Translation');
«ENDIF-»
«EXPAND AddJoin(false, 'from') FOREACH incoming.typeSelect(JoinRelationship)-»
«EXPAND AddJoin(true, 'from') FOREACH outgoing.typeSelect(JoinRelationship)-»
    }
«ENDDEFINE»

«DEFINE AddJoin(Boolean incoming, String target) FOR JoinRelationship-»
«LET getRelationAliasName(incoming).formatForCodeCapital() AS relationAliasName-»
«IF target == 'select'-»
, «relationAliasName».*«""-»
«ELSEIF target == 'from'-»
        $q->«joinCommand(incoming)»('tbl.«relationAliasName» «relationAliasName»');
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE RepositoryTableImpl(Application app) FOR Entity-»

/**
 * Repository class used to implement own convenience methods for performing certain DQL queries.
 *
 * This is the concrete repository class for «name.formatForDisplay()» entities.
 */
class «implClassModelRepository()» extends «IF isInheriting()»«parentType().implClassModelRepository()»«ELSE»«baseClassModelRepository()»«ENDIF»
{
    // feel free to add your own methods here, like for example reusable DQL queries
}
«ENDDEFINE»


«REM»creates a reference table class file for every many-to-many relationship instance«ENDREM»
«DEFINE Root(Application app) FOR ManyToManyRelationship-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModelRefRepository().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRefRepositoryBaseImpl(app)»«ENDFILE»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModelRefRepository().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ModelRefRepositoryImpl(app)»«ENDFILE»
«ENDDEFINE»


«REM»base implementation«ENDREM»
«DEFINE ModelRefRepositoryBaseImpl(Application app) FOR ManyToManyRelationship-»

/**
 * Repository class used to implement own convenience methods for performing certain DQL queries.
 *
 * This is the base repository class for the many to many relationship
 * between «source.name.formatForDisplay()» and «target.name.formatForDisplay()» entities.
 */
class «baseClassModelRefRepository()» extends EntityRepository
{
    public function truncateTable()
    {
        $q = $this->getEntityManager()
            ->createQuery('DELETE «implClassModelRefEntity()»');
        $q->execute();
    }
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE ModelRefRepositoryImpl(Application app) FOR ManyToManyRelationship-»

/**
 * Repository class used to implement own convenience methods for performing certain DQL queries.
 *
 * This is the concrete repository class for the many to many relationship
 * between «source.name.formatForDisplay()» and «target.name.formatForDisplay()» entities.
 */
class «implClassModelRefRepository()» extends «baseClassModelRefRepository()»
{
    // feel free to add your own methods here, like for example reusable DQL queries
}
«ENDDEFINE»
