«IMPORT modulestudio»
«REM«IMPORT templates::zclassic::smallstuff»«ENDREM»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«REMEXTENSION org::eclipse::xtend::util::stdlib::io»«ENDREM»

«REM»creates a base validator class encapsulating common checks«ENDREM»
«DEFINE BaseValidator FOR Application-»
«info("Generating base validator class") -> ""-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassDefault(app, '', 'Validator').asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND BaseValidatorBaseImpl(app)»«ENDFILE»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassDefault(app, '', 'Validator').asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND BaseValidatorImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE BaseValidatorBaseImpl(Application app) FOR Entity-»
/**
 * Validator class for encapsulating common entity validation methods.
 *
 * This is the base validation class with general checks.
 */
abstract class «baseClassDefault('', 'Validator')» extends AbstractBase
{
    /**
     * Checks if field value is a valid DateTime instance.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidDate($fieldName)
    {
        return ($this[$fieldName] instanceof DateTime);
    }

    /**
     * Checks if field value is a date in the future
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isDateInFuture($fieldName)
    {
        return ($this->isValidDate($fieldName) && $this[$fieldName]->format('U') > time());
    }
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE BaseValidatorImpl(Application app) FOR Entity-»

/**
 * Validator class for encapsulating common entity validation methods.
 *
 * This is the concrete validation class with general checks.
 */
class «implClassDefault('', 'Validator')» extends «baseClassModel('', 'Validator')»
{
    // here you can add custom validation methods or override existing checks
}
«ENDDEFINE»


«REM»creates a validator class for every Entity instance«ENDREM»
«DEFINE ValidatorWrapper(Application app) FOR Entity-»
«info("Generating validator classes for entity \"" + name.formatForDisplay() + "\"") -> ""-»
«IF !isInheriting()-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModel('validator', '').asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ValidatorBaseImpl(app)»«ENDFILE»
«ENDIF-»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModel('validator', '').asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ValidatorImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE ValidatorBaseImpl(Application app) FOR Entity-»

/**
 * Validator class for encapsulating entity validation methods.
 *
 * This is the base validation class for «name.formatForDisplay()» entities.
 */
class «baseClassModel('validator', '')» «IF isInheriting()»«parentType().implClassModel('validator', '')»«ELSE»«implClassDefault('', 'Validator')»«ENDIF»
{
«EXPAND ValidatorBaseImpl(app)-»
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE ValidatorImpl(Application app) FOR Entity-»

/**
 * Validator class for encapsulating entity validation methods.
 *
 * This is the concrete validation class for «name.formatForDisplay()» entities.
 */
class «implClassModel('validator', '')» extends «IF isInheriting()»«parentType().implClassModel('validator', '')»«ELSE»«baseClassModel('validator', '')»«ENDIF»
{
    // here you can add custom validation methods or override existing checks
}
«ENDDEFINE»

«DEFINE ValidatorBaseImpl(Application app) FOR Entity»

    /**
     * @var «implClassModelEntity()» The entity class which is treated by this validator.
     */
    protected $entity = null;

    /**
     * Constructor.
     *
     * @param «implClassModelEntity()» $entity The entity to be validated.
     */
    public function __construct(«implClassModelEntity()» $entity)
    {
        $this->entity = $entity;
    }

    /**
     * Performs all validation rules.
     *
     * @return mixed either array with error information or true on success
     */
    public function validateAll()
    {
        $errorInfo = array('message' => '', 'code' => 0, 'debugArray' => array()); 
«REM»TODO
        if (!$this->isValidDate('fieldName')) {
            $errorInfo['message'] = __('Error! Field must be a valid date (%s).', array('fieldName'));
            return $errorInfo;
        }

        if (!$this->isDateInFuture('fieldName')) {
            $errorInfo['message'] = __('Error! Date must be in future (%s).', array('fieldName'));
            return $errorInfo;
        }

«ENDREM»
        return true;
    }

«EXPAND checkForUniqueValues(app) FOREACH getUniqueDerivedFields()-»
«IF sluggable && sluggableCanUpdate && sluggableUnique-»
«EXPAND checkForUniqueSlugValues(app)-»
«ENDIF-»

«EXPAND FileHelper::GetterAndSetterMethods('entity', implClassModelEntity(), false, true, 'null')»
«ENDDEFINE»

«DEFINE checkForUniqueValues(Application app) FOR DerivedField-»

    /**
     * Check for unique values.
     *
     * This method determines if there already exist «entity.nameMultiple.formatForDisplay()» with the same «name.formatForDisplay()».
     *
     * @param «fieldTypeAsString()»  $value The «name.formatForDisplay()» to check.
     * @param int $excludeid      Id of «entity.nameMultiple.formatForDisplay()» to exclude (optional).
     *
     * @return boolean true if the given «name.formatForDisplay()» does already exist
     */
    public function checkIf«name.formatForCodeCapital()»Exists($value, $excludeid = 0)
    {
        if (empty($value)) {
            return false;
        }

        $objectType = '«entity.name.formatForCode()»';
        $entityClass = '«appName()»_Entity_' . ucfirst($objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        // TODO: move to «IF entity.isInheriting()»«entity.parentType().baseClassModel('repository', '')»«ELSE»«entity.baseClassModel('repository', '')»«ENDIF»
        $where = 'tbl.«name.formatForCode()» = \'' . DataUtil::formatForStore($value) . '\'';
        if ($excludeid > 0) {
            $where .= ' AND tbl.«entity.idField()» != \'' . (int) DataUtil::formatForStore($excludeid) . '\'';
        }
        return $repository->selectCount($where);
    }
«ENDDEFINE»

«DEFINE checkForUniqueSlugValues(Application app) FOR Entity-»

    /**
     * Check for unique slug values.
     *
     * This method determines if there already exist «nameMultiple.formatForDisplay()» with the same «sluggableFieldRealName.formatForDisplay()».
     *
     * @param string  $value The «sluggableFieldRealName.formatForDisplay()» to check.
     * @param int $excludeid      Id of «nameMultiple.formatForDisplay()» to exclude (optional).
     *
     * @return boolean true if the given slug does already exist
     */
    public function checkIfSlugExists($value, $excludeid = 0)
    {
        if (empty($value)) {
            return false;
        }

        $objectType = '«name.formatForCode()»';
        $entityClass = '«appName()»_Entity_' . ucfirst($objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        // TODO: move to «IF isInheriting()»«parentType().baseClassModel('repository', '')»«ELSE»«baseClassModel('repository', '')»«ENDIF»
        $where = 'tbl.slug» = \'' . DataUtil::formatForStore($value) . '\'';
        if ($excludeid > 0) {
            $where .= ' AND tbl.«idField()» != \'' . (int) DataUtil::formatForStore($excludeid) . '\'';
        }
        return $repository->selectCount($where);
    }
«ENDDEFINE»


«REM» TODO

some validators to be reimplemented:

«DEFINE FieldLength FOR DerivedField-»null«ENDDEFINE»
«DEFINE FieldLength FOR AbstractIntegerField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR DecimalField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR StringField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR EmailField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR UrlField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR UploadField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR ArrayField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR FloatField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»


«DEFINE FieldSetColumnAdditionalOptions FOR DerivedField-»«ENDDEFINE»

«DEFINE FieldSetColumnAdditionalOptions FOR IntegerField-»
«IF minValue != 0 || maxValue != 0-»
                // Check if value is in range specified by arguments
                'range' => array(«minValue», «maxValue»),
«ENDIF-»
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR DecimalField-»
                'scale' => «scale.toInteger()»,
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptionsCommon FOR AbstractStringField-»
«IF fixed-»
                'fixed' => true,
«ENDIF-»
«IF nospace-»
                // check if value has no space chars
                'nospace' => true,
«ENDIF-»
«IF minLength != null && minLength > 0-»
                // check if value satisfies the minimum length
                'minlength' => «minLength»,
«ENDIF-»
«IF regexp != null && regexp != ""-»
                // check if value matches a regular expression
                'regexp' => '«regexp»',
«ENDIF-»

«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR AbstractStringField-»
«EXPAND FieldSetColumnAdditionalOptionsCommon-»
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR StringField-»
«EXPAND FieldSetColumnAdditionalOptionsCommon-»
«IF country-»
                // check if value is a valid country code
                'country' => true,
«ENDIF-»
«IF ipaddress-»
                // check if value is a valid ip address
                'ip' => true,
«ENDIF-»
«IF htmlcolor-»
                // check if value is a valid html colour
                'htmlcolor' => true,
«ENDIF-»
«ENDDEFINE»

«DEFINE FieldSetColumnAdditionalOptions FOR EmailField-»
«EXPAND FieldSetColumnAdditionalOptionsCommon-»
«IF !mandatory»/* inactive because field is not mandatory«ENDIF»
                // check if value is a valid email address
                'email' => true,
«IF !mandatory»*/«ENDIF»
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR AbstractDateField-»
«IF past-»
                // check if value is a date in the past
                'past' => true,
«ELSEIF future-»
                // check if value is a date in the future
                'future' => true,
«ENDIF-»
«ENDDEFINE»


«ENDREM»