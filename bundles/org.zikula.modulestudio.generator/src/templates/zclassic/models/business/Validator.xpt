«IMPORT modulestudio»
«REM«IMPORT templates::zclassic::smallstuff»«ENDREM»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«REMEXTENSION org::eclipse::xtend::util::stdlib::io»«ENDREM»

«REM»creates a business validator file for every Entity instance«ENDREM»
«DEFINE BusinessValidatorWrapper(Application app) FOR Entity-»
«info("Generating business validator classes for entity \"" + name.formatForDisplay() + "\"") -> ""-»
«IF !isInheriting()-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassBusinessValidator().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND BusinessValidatorBaseImpl(app)»«ENDFILE»
«ENDIF-»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassBusinessValidator().asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND BusinessValidatorImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE BusinessValidatorBaseImpl(Application app) FOR Entity-»

/**
 * Business validator class for encapsulating validation methods.
 *
 * This is the base validation class for «name.formatForDisplay()» entities.
 */
abstract class «baseClassBusinessValidator()»
{
«EXPAND BusinessValidatorBaseImpl(app)-»
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE BusinessValidatorImpl(Application app) FOR Entity-»

/**
 * Business validator class for encapsulating validation methods.
 *
 * This is the concrete validation class for «name.formatForDisplay()» entities.
 */
class «implClassBusinessValidator()» extends «IF isInheriting()»«parentType().implClassBusinessValidator()»«ELSE»«baseClassBusinessValidator()»«ENDIF»
{
    // here you can add custom validation methods or override existing checks
}
«ENDDEFINE»

«DEFINE BusinessValidatorBaseImpl(Application app) FOR Entity»

    /**
     * @var «implClassBusinessEntity(false)» The entity class which is treated by this validator.
     */
    protected $entity = null;

    /**
     * Constructor.
     *
     * @param «implClassBusinessEntity(false)» $entity The entity to be validated.
     */
    function __construct(«implClassBusinessEntity(false)» $entity)
    {
        $this->entity = $entity;
    }

«EXPAND checkForUniqueValues(app) FOREACH getUniqueDerivedFields()-»
«IF sluggable && sluggableCanUpdate && sluggableUnique-»
«EXPAND checkForUniqueSlugValues(app)-»
«ENDIF-»

«EXPAND FileHelper::GetterAndSetterMethods('entity', implClassBusinessEntity(false))»
«ENDDEFINE»

«DEFINE checkForUniqueValues(Application app) FOR DerivedField-»

    /**
     * Check for unique values.
     *
     * This method determines if there already exist «entity.nameMultiple.formatForDisplay()» with the same «actualFieldName().formatForDisplay()».
     *
     * @param «fieldTypeAsString()»  $value The «actualFieldName().formatForDisplay()» to check.
     * @param int $excludeid      int    Id of «entity.nameMultiple.formatForDisplay()» to exclude (optional).
     *
     * @return boolean true if the given «actualFieldName().formatForDisplay()» does already exist
     */
    public function checkIf«actualFieldName().formatForCodeCapital()»Exists($value, $excludeid = 0)
    {
        if (empty($value)) {
            return false;
        }

        $objectType = '«entity.name.formatForCode()»';
«EXPAND templates::zclassic::controller::ControllerHelper::instantiateBusinessObject(app.appName(), true, 'validator', entity.name, 'checkIf'.msconcat(actualFieldName().formatForCodeCapital()).msconcat('Exists'))-»

        // TODO: move to «IF entity.isInheriting()»«entity.parentType().baseClassModelTable()»«ELSE»«entity.baseClassModelTable()»«ENDIF»
        $where = 'tbl.«actualFieldName().formatForCode()» = \'' . DataUtil::formatForStore($value) . '\'';
        if ($excludeid > 0) {
            $where .= ' AND tbl.«entity.idField()» != \'' . (int) DataUtil::formatForStore($excludeid) . '\'';
        }
        return $objectCollection->selectCount($where);
    }
«ENDDEFINE»

«DEFINE checkForUniqueSlugValues(Application app) FOR Entity-»

    /**
     * Check for unique slug values.
     *
     * This method determines if there already exist «nameMultiple.formatForDisplay()» with the same «sluggableFieldRealName.formatForDisplay()».
     *
     * @param string  $value The «sluggableFieldRealName.formatForDisplay()» to check.
     * @param int $excludeid      int    Id of «nameMultiple.formatForDisplay()» to exclude (optional).
     *
     * @return boolean true if the given slug does already exist
     */
    public function checkIfSlugExists($value, $excludeid = 0)
    {
        if (empty($value)) {
            return false;
        }

        $objectType = '«name.formatForCode()»';
«EXPAND templates::zclassic::controller::ControllerHelper::instantiateBusinessObject(app.appName(), true, 'validator', name, 'checkIf'.msconcat(sluggableFieldRealName.formatForCodeCapital()).msconcat('Exists'))-»

        // TODO: move to «IF isInheriting()»«parentType().baseClassModelTable()»«ELSE»«baseClassModelTable()»«ENDIF»
        $where = 'tbl.slug» = \'' . DataUtil::formatForStore($value) . '\'';
        if ($excludeid > 0) {
            $where .= ' AND tbl.«idField()» != \'' . (int) DataUtil::formatForStore($excludeid) . '\'';
        }
        return $objectCollection->selectCount($where);
    }
«ENDDEFINE»


«REM TODO

some validators to be reimplemented:

«DEFINE FieldLength FOR DerivedField-»null«ENDDEFINE»
«DEFINE FieldLength FOR AbstractIntegerField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR FloatField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR DecimalField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR StringField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR EmailField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR UrlField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR UploadField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»
«DEFINE FieldLength FOR ArrayField-»«IF length != null && length != ""-»«length»«ELSE-»null«ENDIF-»«ENDDEFINE»


«DEFINE FieldSetColumnAdditionalOptions FOR DerivedField-»«ENDDEFINE»

«DEFINE FieldSetColumnAdditionalOptions FOR IntegerField-»
«IF minValue != 0 || maxValue != 0-»
                // Check if value is in range specified by arguments
                'range' => array(«minValue», «maxValue»),
«ENDIF-»
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR DecimalField-»
                'scale' => «scale.toInteger()»,
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptionsCommon FOR AbstractStringField-»
«IF fixed-»
                'fixed' => true,
«ENDIF-»
«IF nospace-»
                // check if value has no space chars
                'nospace' => true,
«ENDIF-»
«IF minLength != null && minLength > 0-»
                // check if value satisfies the minimum length
                'minlength' => «minLength»,
«ENDIF-»
«IF regexp != null && regexp != ""-»
                // check if value matches a regular expression
                'regexp' => '«regexp»',
«ENDIF-»

«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR AbstractStringField-»
«EXPAND FieldSetColumnAdditionalOptionsCommon-»
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR StringField-»
«EXPAND FieldSetColumnAdditionalOptionsCommon-»
«IF country-»
                // check if value is a valid country code
                'country' => true,
«ENDIF-»
«IF ipaddress-»
                // check if value is a valid ip address
                'ip' => true,
«ENDIF-»
«IF htmlcolor-»
                // check if value is a valid html colour
                'htmlcolor' => true,
«ENDIF-»
«ENDDEFINE»

«DEFINE FieldSetColumnAdditionalOptions FOR EmailField-»
«EXPAND FieldSetColumnAdditionalOptionsCommon-»
«IF !mandatory»/* inactive because field is not mandatory«ENDIF»
                // check if value is a valid email address
                'email' => true,
«IF !mandatory»*/«ENDIF»
«ENDDEFINE»
«DEFINE FieldSetColumnAdditionalOptions FOR AbstractDateField-»
«IF past-»
                // check if value is a date in the past
                'past' => true,
«ELSEIF future-»
                // check if value is a date in the future
                'future' => true,
«ENDIF-»
«ENDDEFINE»


«ENDREM»