«IMPORT modulestudio»
«IMPORT templates::zclassic::smallstuff»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«EXTENSION org::eclipse::xtend::util::stdlib::io»

«REM»creates a base validator class encapsulating common checks«ENDREM»
«DEFINE BaseValidator FOR Application-»
«info("Generating base validator class") -> ""-»
    «FILE getAppSourcePath(appName()).msconcat(baseClassDefault(this, '', 'Validator').asFile())»«EXPAND FileHelper::phpFileHeader(this)»«EXPAND BaseValidatorBaseImpl-»«ENDFILE»
    «FILE getAppSourcePath(appName()).msconcat(implClassDefault(this, '', 'Validator').asFile())»«EXPAND FileHelper::phpFileHeader(this)»«EXPAND BaseValidatorImpl-»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE BaseValidatorBaseImpl FOR Application-»
/**
 * Validator class for encapsulating common entity validation methods.
 *
 * This is the base validation class with general checks.
 */
abstract class «baseClassDefault(this, '', 'Validator')» extends AbstractBase
{
    /**
     * @var Zikula_EntityAccess The entity instance which is treated by this validator.
     */
    protected $entity = null;

    /**
     * Constructor.
     *
     * @param Zikula_EntityAccess $entity The entity to be validated.
     */
    public function __construct(Zikula_EntityAccess $entity)
    {
        $this->entity = $entity;
    }

    /**
     * Checks if field value is a valid boolean.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidBoolean($fieldName)
    {
        return (is_bool($this->entity[$fieldName]));
    }

    /**
     * Checks if field value is a valid number.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidNumber($fieldName)
    {
        return (is_numeric($this->entity[$fieldName]));
    }

    /**
     * Checks if field value is a valid integer.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidInteger($fieldName)
    {
        return (is_int($this->entity[$fieldName]));
    }

    /**
     * Checks if integer field value is not lower than a given value.
     *
     * @param string $fieldName The name of the property to be checked
     * @param int    $value     The maximum allowed value
     * @return boolean result of this check
     */
    public function isIntegerNotLowerThan($fieldName, $value)
    {
        return ($this->isValidInteger($fieldName) && $this->entity[$fieldName] >= $value);
    }

    /**
     * Checks if integer field value is not higher than a given value.
     *
     * @param string $fieldName The name of the property to be checked
     * @param int    $value     The maximum allowed value
     * @return boolean result of this check
     */
    public function isIntegerNotHigherThan($fieldName, $value)
    {
        return ($this->isValidInteger($fieldName) && $this->entity[$fieldName] <= $value);
    }

    /**
     * Checks if field value is a valid user id.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidUser($fieldName)
    {
        if (!$this->isValidInteger($fieldName)) {
            return false;
        }
        $uname = UserUtil::getVar('uname', $this->entity[$fieldName]);
        return (!is_null($uname) && !empty($uname));
    }

    /**
     * Checks if numeric field value has a value other than 0.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isNumberNotEmpty($fieldName)
    {
        return $this->entity[$fieldName] != 0;
    }

    /**
     * Checks if string field value has a value other than ''.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isStringNotEmpty($fieldName)
    {
        return $this->entity[$fieldName] != '';
    }

    /**
     * Checks if numeric field value has a given minimum field length
     *
     * @param string $fieldName The name of the property to be checked
     * @param int    $length    The minimum length
     * @return boolean result of this check
     */
    public function isNumberNotShorterThan($fieldName, $length)
    {
        $minValue = pow(10, $length-1);
        return ($this->isValidNumber($fieldName) && $this->entity[$fieldName] > $minValue);
    }

    /**
     * Checks if numeric field value does fit into given field length.
     *
     * @param string $fieldName The name of the property to be checked
     * @param int    $length    The maximum allowed length
     * @return boolean result of this check
     */
    public function isNumberNotLongerThan($fieldName, $length)
    {
        $maxValue = pow(10, $length);
        return ($this->isValidNumber($fieldName) && $this->entity[$fieldName] < $maxValue);
    }

    /**
     * Checks if string field value has a given minimum field length.
     *
     * @param string $fieldName The name of the property to be checked
     * @param int    $length    The minimum length
     * @return boolean result of this check
     */
    public function isStringNotShorterThan($fieldName, $length)
    {
        return (strlen($this->entity[$fieldName]) >= $length);
    }

    /**
     * Checks if string field value does fit into given field length.
     *
     * @param string $fieldName The name of the property to be checked
     * @param int    $length    The maximum allowed length
     * @return boolean result of this check
     */
    public function isStringNotLongerThan($fieldName, $length)
    {
        return (strlen($this->entity[$fieldName]) <= $length);
    }

    /**
     * Checks if string field value does conform to given fixed field length.
     *
     * @param string $fieldName The name of the property to be checked
     * @param int    $length    The fixed length
     * @return boolean result of this check
     */
    public function isStringWithFixedLength($fieldName, $length)
    {
        return (strlen($this->entity[$fieldName]) == $length);
    }

    /**
     * Checks if string field value does not contain a given string.
     *
     * @param string  $fieldName     The name of the property to be checked
     * @param string  $keyword       The char or string to search for
     * @param boolean $caseSensitive Whether the search should be case sensitive or not (default false)
     * @return boolean result of this check
     */
    public function isStringNotContaining($fieldName, $keyword, $caseSensitive = false)
    {
        if ($caseSensitive === true) {
            return (strstr($this->entity[$fieldName], $keyword) !== false);
        }
        return (stristr($this->entity[$fieldName], $keyword) !== false);
    }

    /**
     * Checks if string field value conforms to a given regular expression.
     *
     * @param string  $fieldName     The name of the property to be checked
     * @param string  $expression    Regular expression string
     * @return boolean result of this check
     */
    public function isValidRegExp($fieldName, $expression)
    {
        return preg_match($expression, $this->entity[$fieldName]);
    }

    /**
     * Checks if string field value is a valid language code.
     *
     * @param string  $fieldName     The name of the property to be checked
     * @param boolean $onlyInstalled Whether to accept only installed languages (default false)
     * @return boolean result of this check
     */
    public function isValidLanguage($fieldName, $onlyInstalled = false)
    {
        $languageMap = ZLanguage::languageMap();
        $result = in_array($this->entity[$fieldName], array_keys($languageMap));        
        if (!$result || !$onlyInstalled) {
            return $result;
        } 
        $available = ZLanguage::getInstalledLanguages();
        return in_array($this->entity[$fieldName], $available);
    }

    /**
     * Checks if string field value is a valid country code.
     *
     * @param string  $fieldName     The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidCountry($fieldName)
    {
        $countryMap = ZLanguage::countryMap();
        return in_array($this->entity[$fieldName], array_keys($countryMap));
    }

    /**
     * Checks if string field value is a valid html colour.
     *
     * @param string  $fieldName     The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidHtmlColour($fieldName)
    {
        $regex = '/^#?(([a-fA-F0-9]{3}){1,2})$/';
        return preg_match($regex, $this->entity[$fieldName]);
    }

    /**
     * Checks if field value is a valid email address.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidEmail($fieldName)
    {
        $regex = '/^[^0-9][a-zA-Z0-9_]+(\.[a-zA-Z0-9_]+)*[@][a-zA-Z0-9_]+(\.[a-zA-Z0-9_]+)*\.[a-zA-Z]{2,5}$/';
        return preg_match($regex, $this->entity[$fieldName]);
    }

    /**
     * Checks if field value is a valid url.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidUrl($fieldName)
    {
        $regex = '(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\\+#])?';
        return preg_match($regex, $this->entity[$fieldName]);
    }

    /**
     * Checks if field value is a valid DateTime instance.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isValidDateTime($fieldName)
    {
        return ($this->entity[$fieldName] instanceof DateTime);
    }

    /**
     * Checks if field value has a value in the past.
     *
     * @param string $fieldName The name of the property to be checked
     * @param string $format    The date format used for comparison
     * @return boolean result of this check
     */
    protected function isDateTimeValueInPast($fieldName, $format)
    {
        return ($this->isValidDateTime($fieldName) && $this->entity[$fieldName]->format($format) < date($format));
    }

    /**
     * Checks if field value has a value in the future.
     *
     * @param string $fieldName The name of the property to be checked
     * @param string $format    The date format used for comparison
     * @return boolean result of this check
     */
    protected function isDateTimeValueInFuture($fieldName, $format)
    {
        return ($this->isValidDateTime($fieldName) && $this->entity[$fieldName]->format($format) > date($format));
    }

    /**
     * Checks if field value is a datetime in the past.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isDateTimeInPast($fieldName)
    {
        return $this->isDateTimeValueInPast($fieldName, 'U');
    }

    /**
     * Checks if field value is a datetime in the future.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isDateTimeInFuture($fieldName)
    {
        return $this->isDateTimeValueInFuture($fieldName, 'U');
    }

    /**
     * Checks if field value is a date in the past.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isDateInPast($fieldName)
    {
        return $this->isDateTimeValueInPast($fieldName, 'Ymd');
    }

    /**
     * Checks if field value is a date in the future.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isDateInFuture($fieldName)
    {
        return $this->isDateTimeValueInFuture($fieldName, 'Ymd');
    }

    /**
     * Checks if field value is a time in the past.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isTimeInPast($fieldName)
    {
        return $this->isDateTimeValueInPast($fieldName, 'His');
    }

    /**
     * Checks if field value is a time in the future.
     *
     * @param string $fieldName The name of the property to be checked
     * @return boolean result of this check
     */
    public function isTimeInFuture($fieldName)
    {
        return $this->isDateTimeValueInFuture($fieldName, 'His');
    }
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE BaseValidatorImpl FOR Application-»

/**
 * Validator class for encapsulating common entity validation methods.
 *
 * This is the concrete validation class with general checks.
 */
class «implClassDefault(this, '', 'Validator')» extends «baseClassDefault(this, '', 'Validator')»
{
    // here you can add custom validation methods or override existing checks
}
«ENDDEFINE»


«REM»creates a validator class for every Entity instance«ENDREM»
«DEFINE ValidatorWrapper(Application app) FOR Entity-»
«info("Generating validator classes for entity \"" + name.formatForDisplay() + "\"") -> ""-»
«IF !isInheriting()-»
    «FILE getAppSourcePath(app.appName()).msconcat(baseClassModel('validator', '').asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ValidatorBaseImpl(app)»«ENDFILE»
«ENDIF-»
    «FILE getAppSourcePath(app.appName()).msconcat(implClassModel('validator', '').asFile())»«EXPAND FileHelper::phpFileHeader(app)»«EXPAND ValidatorImpl(app)»«ENDFILE»
«ENDDEFINE»

«REM»base implementation«ENDREM»
«DEFINE ValidatorBaseImpl(Application app) FOR Entity-»

/**
 * Validator class for encapsulating entity validation methods.
 *
 * This is the base validation class for «name.formatForDisplay()» entities.
 */
class «baseClassModel('validator', '')» «IF isInheriting()»«parentType().implClassModel('validator', '')»«ELSE»«implClassDefault(app, '', 'Validator')»«ENDIF»
{
«EXPAND ValidatorBaseImplBody(app)-»
}
«ENDDEFINE»

«REM»concrete implementation stub«ENDREM»
«DEFINE ValidatorImpl(Application app) FOR Entity-»

/**
 * Validator class for encapsulating entity validation methods.
 *
 * This is the concrete validation class for «name.formatForDisplay()» entities.
 */
class «implClassModel('validator', '')» extends «IF isInheriting()»«parentType().implClassModel('validator', '')»«ELSE»«baseClassModel('validator', '')»«ENDIF»
{
    // here you can add custom validation methods or override existing checks
}
«ENDDEFINE»

«DEFINE ValidatorBaseImplBody(Application app) FOR Entity»

    /**
     * Performs all validation rules.
     *
     * @return mixed either array with error information or true on success
     */
    public function validateAll()
    {
        $errorInfo = array('message' => '', 'code' => 0, 'debugArray' => array()); 
«EXPAND ValidationCalls FOREACH getDerivedFields()-»
        return true;
    }

«EXPAND checkForUniqueValues(app) FOREACH getUniqueDerivedFields()-»
«IF hasSluggableFields() && slugUpdatable && slugUnique-»
«EXPAND checkForUniqueSlugValues(app)-»
«ENDIF-»

«EXPAND FileHelper::GetterAndSetterMethods('entity', 'Zikula_EntityAccess', false, true, 'null')»
«ENDDEFINE»

«DEFINE ValidationCalls FOR DerivedField-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR BooleanField-»
        if (!$this->isValidBoolean('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a valid boolean (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDDEFINE»

«DEFINE ValidationCallsNumeric FOR DerivedField-»
        if (!$this->isValidNumber('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be numeric (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«IF mandatory-»
        if (!$this->isNumberNotEmpty('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must not be 0 (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«ENDDEFINE»

«DEFINE ValidationCallsInteger FOR AbstractIntegerField-»
        if (!$this->isValidInteger('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value may only contain digits (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«IF mandatory-»
        if (!$this->isNumberNotEmpty('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must not be 0 (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR AbstractIntegerField-»
«EXPAND ValidationCallsInteger-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR IntegerField-»
«EXPAND ValidationCallsInteger-»
«IF minValue != 0-»
        if (!$this->isIntegerNotLowerThan('«name.formatForCode()»', «minValue»)) {
            $errorInfo['message'] = __('Error! Field value must not be lower than %2$s (%1$s).', array('«name.formatForCode()»', «minValue»));
            return $errorInfo;
        }
«ENDIF-»
«IF maxValue != 0-»
        if (!$this->isIntegerNotHigherThan('«name.formatForCode()»', «maxValue»)) {
            $errorInfo['message'] = __('Error! Field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «maxValue»));
            return $errorInfo;
        }
«ENDIF-»
        if (!$this->isNumberNotLongerThan('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
«ENDDEFINE»
«DEFINE ValidationCalls FOR DecimalField-»
«EXPAND ValidationCallsNumeric-»
        if (!$this->isNumberNotLongerThan('«name.formatForCode()»', «(length+scale)»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «(length+scale)»));
            return $errorInfo;
        }
«ENDDEFINE»
«DEFINE ValidationCalls FOR UserField-»
«EXPAND ValidationCallsInteger-»
        if («IF !mandatory-»$this->entity['«name.formatForCode()»'] > 0 && «ENDIF-»!$this->isValidUser('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value be a valid user id (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDDEFINE»

«DEFINE ValidationCallsString FOR AbstractStringField-»
«IF mandatory-»
        if (!$this->isStringNotEmpty('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must not be empty (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«IF nospace-»
        if (!$this->isStringNotContaining('«name.formatForCode()»', ' ')) {
            $errorInfo['message'] = __('Error! Field value must not contain space chars (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«IF minLength > 0-»
        if (!$this->isStringNotShorterThan('«name.formatForCode()»', «minLength»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be smaller than %2$s (%1$s).', array('«name.formatForCode()»', «minLength»));
            return $errorInfo;
        }
«ENDIF-»
«IF regexp != null && regexp != ''-»
        if (!$this->isValidRegExp('«name.formatForCode()»', «regexp»)) {
            $errorInfo['message'] = __('Error! Field value must conform to regular expression [%2$s] (%1$s).', array('«name.formatForCode()»', '«regexp»'));
            return $errorInfo;
        }
«ENDIF-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR AbstractStringField-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR StringField-»
        if (!$this->isStringNotLongerThan('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
«IF fixed-»
        if (!$this->isStringWithFixedLength('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value be %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
«ENDIF-»
«IF language-»
        if («IF !mandatory-»$this->entity['«name.formatForCode()»'] != '' && «ENDIF-»!$this->isValidLanguage('«name.formatForCode()»', false)) {
            $errorInfo['message'] = __('Error! Field value must be a valid language code (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«IF country-»
        if («IF !mandatory-»$this->entity['«name.formatForCode()»'] != '' && «ENDIF-»!$this->isValidCountry('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a valid country code (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«IF htmlcolour-»
        if («IF !mandatory-»$this->entity['«name.formatForCode()»'] != '' && «ENDIF-»!$this->isValidHtmlColour('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a valid html colour code [#123 or #123456] (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR TextField-»
        if (!$this->isStringNotLongerThan('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
«ENDDEFINE»
«DEFINE ValidationCalls FOR EmailField-»
        if (!$this->isStringNotLongerThan('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
        if («IF !mandatory-»$this->entity['«name.formatForCode()»'] != '' && «ENDIF-»!$this->isValidEmail('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a valid email address (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDDEFINE»
«DEFINE ValidationCalls FOR UrlField-»
        if (!$this->isStringNotLongerThan('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
        if («IF !mandatory-»$this->entity['«name.formatForCode()»'] != '' && «ENDIF-»!$this->isValidUrl('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a valid url (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDDEFINE»
«DEFINE ValidationCalls FOR UploadField-»
        if (!$this->isStringNotLongerThan('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
«ENDDEFINE»
«DEFINE ValidationCalls FOR ArrayField-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR ObjectField-»
«ENDDEFINE»
«DEFINE ValidationCallsDateTime FOR AbstractDateField-»
        if (!$this->isValidDateTime('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a valid datetime (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDDEFINE»
«DEFINE ValidationCalls FOR AbstractDateField-»
«EXPAND ValidationCallsDateTime-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR DatetimeField-»
«EXPAND ValidationCallsDateTime-»
«IF past-»
        if (!$this->isDateTimeInPast('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a date in the past (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ELSEIF future-»
        if (!$this->isDateTimeInFuture('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a date in the future (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR DateField-»
«EXPAND ValidationCallsDateTime-»
«IF past-»
        if (!$this->isDateInPast('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a date in the past (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ELSEIF future-»
        if (!$this->isDateInFuture('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a date in the future (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR TimeField-»
«EXPAND ValidationCallsDateTime-»
«IF past-»
        if (!$this->isTimeInPast('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a time in the past (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ELSEIF future-»
        if (!$this->isTimeInFuture('«name.formatForCode()»')) {
            $errorInfo['message'] = __('Error! Field value must be a time in the future (%s).', array('«name.formatForCode()»'));
            return $errorInfo;
        }
«ENDIF-»
«ENDDEFINE»
«DEFINE ValidationCalls FOR FloatField-»
«EXPAND ValidationCallsNumeric-»
        if (!$this->isNumberNotLongerThan('«name.formatForCode()»', «length»)) {
            $errorInfo['message'] = __('Error! Length of field value must not be higher than %2$s (%1$s).', array('«name.formatForCode()»', «length»));
            return $errorInfo;
        }
«ENDDEFINE»







«DEFINE checkForUniqueValues(Application app) FOR DerivedField-»

    /**
     * Check for unique values.
     *
     * This method determines if there already exist «entity.nameMultiple.formatForDisplay()» with the same «name.formatForDisplay()».
     *
     * @param «fieldTypeAsString()»  $value The «name.formatForDisplay()» to check.
     * @param int $excludeid      Id of «entity.nameMultiple.formatForDisplay()» to exclude (optional).
     *
     * @return boolean true if the given «name.formatForDisplay()» does already exist
     */
    public function checkIf«name.formatForCodeCapital()»Exists($value, $excludeid = 0)
    {
        if (empty($value)) {
            return false;
        }

        $objectType = '«entity.name.formatForCode()»';
        $entityClass = '«app.appName()»_Entity_' . ucfirst($objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        // TODO: move to «IF entity.isInheriting()»«entity.parentType().baseClassModel('repository', '')»«ELSE»«entity.baseClassModel('repository', '')»«ENDIF» (#37)
        $where = 'tbl.«name.formatForCode()» = \'' . DataUtil::formatForStore($value) . '\'';
        if ($excludeid > 0) {
            $where .= ' AND tbl.id != \'' . (int) DataUtil::formatForStore($excludeid) . '\'';
        }
        return $repository->selectCount($where);
    }
«ENDDEFINE»

«DEFINE checkForUniqueSlugValues(Application app) FOR Entity-»

    /**
     * Check for unique slug values.
     *
     * This method determines if there already exist «nameMultiple.formatForDisplay()» with the same slug.
     *
     * @param string  $value The slug to check.
     * @param int $excludeid      Id of «nameMultiple.formatForDisplay()» to exclude (optional).
     *
     * @return boolean true if the given slug does already exist
     */
    public function checkIfSlugExists($value, $excludeid = 0)
    {
        if (empty($value)) {
            return false;
        }

        $objectType = '«name.formatForCode()»';
        $entityClass = '«app.appName()»_Entity_' . ucfirst($objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        // TODO: move to «IF isInheriting()»«parentType().baseClassModel('repository', '')»«ELSE»«baseClassModel('repository', '')»«ENDIF» (#37)
        $where = 'tbl.slug = \'' . DataUtil::formatForStore($value) . '\'';
        if ($excludeid > 0) {
            $where .= ' AND tbl.id != \'' . (int) DataUtil::formatForStore($excludeid) . '\'';
        }
        return $repository->selectCount($where);
    }
«ENDDEFINE»
