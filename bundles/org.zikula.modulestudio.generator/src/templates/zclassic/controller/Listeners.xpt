«IMPORT modulestudio»
«IMPORT templates::zclassic::smallstuff»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«EXTENSION org::eclipse::xtend::util::stdlib::io»

«REM»Entry point for persistent event listeners«ENDREM»
«DEFINE Root FOR Application»
«FILE getAppSourceLibPath(appName()).msconcat("Base/Listeners.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class
 */
class «appName()»_Base_Listeners
{
«EXPAND BaseListeners-»
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listeners.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class.
 */
class «appName()»_Listeners extends «appName()»_Base_Listeners
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«ENDDEFINE»

«DEFINE BaseListeners FOR Application-»
    // core

    /**
     * Listener for the `api.method_not_found` event.
     *
     * Called in instances of Zikula_Api from __call().
     * Receives arguments from __call($method, argument) as $args.
     *     $event['method'] is the method which didn't exist in the main class.
     *     $event['args'] is the arguments that were passed.
     * The event subject is the class where the method was not found.
     * Must exit if $event['method'] does not match whatever the handler expects.
     * Modify $event->data and $event->setNotify().
     */
    public static function coreApiMethodNotFound(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.preinit` event.
     *
     * Occurs after the config.php is loaded.
     */
    public static function corePreInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.init` event.
     *
     * Occurs after each `System::init()` stage, `$event['stage']` contains the stage.
     * To check if the handler should execute, do `if($event['stage'] & System::CORE_STAGES_*)`.
     */
    public static function coreInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.postinit` event.
     *
     * Occurs just before System::init() exits from normal execution.
     */
    public static function corePostInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `controller.method_not_found` event.
     *
     * Called in instances of `Zikula_Controller` from `__call()`.
     * Receives arguments from `__call($method, argument)` as `$args`.
     *    `$event['method']` is the method which didn't exist in the main class.
     *    `$event['args']` is the arguments that were passed.
     * The event subject is the class where the method was not found.
     * Must exit if `$event['method']` does not match whatever the handler expects.
     * Modify `$event->data` and `$event->setNotify()`.
     */
    public static function coreControllerMethodNotFound(Zikula_Event $event)
    {
        // You can have multiple of these methods.
        // See system/Modules/lib/Modules/HookUI.php for an example.
    }


    // modules

    /**
     * Listener for the `installer.module.installed` event.
     *
     * Called after a module is successfully installed.
     * Receives `$modinfo` as args.
     */
    public static function installerModuleInstalled(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `installer.module.upgraded` event.
     *
     * Called after a module is successfully upgraded.
     * Receives `$modinfo` as args.
     */
    public static function installerModuleUpgraded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `installer.module.uninstalled` event.
     *
     * Called after a module is successfully uninstalled.
     * Receives `$modinfo` as args.
     */
    public static function installerModuleUninstalled(Zikula_Event $event)
    {
    }


    /**
     * Listener for the `module_dispatch.postloadgeneric` event.
     *
     * Called after a module api or controller has been loaded.
     * Receives the args `array('modinfo' => $modinfo, 'type' => $type, 'force' => $force, 'api' => $api)`.
     */
    public static function moduleDispatchPostLoadGeneric(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.preexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     * `array('modname' => $modname, 'modfunc' => $modfunc, 'args' => $args, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`.
     */
    public static function moduleDispatchPreExecute(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.postexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     * `array('modname' => $modname, 'modfunc' => $modfunc, 'args' => $args, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`.
     * Receives the modules output with `$event->getData();`.
     * Can modify this output with `$event->setData($data);`.
     */
    public static function moduleDispatchPostExecute(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.custom_classname` event.
     *
     * In order to override the classname calculated in `ModUtil::exec()`.
     * In order to override a pre-existing controller/api method, use this event type to override the class name that is loaded.
     * This allows to override the methods using inheritance.
     * Receives no subject, args of `array('modname' => $modname, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`
     * and 'event data' of `$className`. This can be altered by setting `$event->setData()` followed by `$event->setNotified()`.
     */
    public static function moduleDispatchCustomClassname(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module.mailer.api.sendmessage` event.
     *
     * Invoked from `Mailer_Api_User#sendmessage`.
     * Subject is `Mailer_Api_User` with `$args`.
     * This is a notifyUntil event so the event must `$event->setNotified()` and set any
     * return data into `$event->data`, or `$event->setData()`.
     */
    public static function moduleMailerApiSendmessage(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `pageutil.addvar_filter` event.
     *
     * Used to override things like system or module stylesheets or javascript.
     * Subject is the `$varname`, and `$event->data` an array of values to be modified by the filter.
     *
     * This single filter can be used to override all css or js scripts or any other var types
     * sent to `PageUtil::addVar()`.
     */
    public static function pageutilAddvarFilter(Zikula_Event $event)
    {
       // Simply test with something like
/*
       if (($key = array_search('system/Users/javascript/somescript.js', $event->data)) !== false) {
           $event->data[$key] = 'config/javascript/myoverride.js';
       }
*/
    }


    // errors

    /**
     * Listener for the `setup.errorreporting` event.
     *
     * Invoked during `System::init()`.
     * Used to activate `set_error_handler()`.
     * Event must `setNotified()`.
     */
    public static function setupErrorReporting(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `system.outputfilter` event.
     *
     * Filter type event for output filter HTML sanitisation.
     */
    public static function systemOutputFilter(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `systemerror` event.
     *
     * Invoked on any system error.
     * args gets `array('errorno' => $errno, 'errstr' => $errstr, 'errfile' => $errfile, 'errline' => $errline, 'errcontext' => $errcontext)`.
     */
    public static function systemError(Zikula_Event $event)
    {
    }


    // themes and views

    /**
     * Listener for the `theme.init` event.
     *
     * Occurs just before `Theme#__construct()` exits. Subject is `$this`, args are
     * `array('theme' => $theme, 'usefilters' => $usefilters, 'themeinfo' => $themeinfo)`.
     */
    public static function themeInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.load_config` event.
     *
     * Runs just before `Theme#_load_config()` completed.
     * Subject is the Theme instance.
     */
    public static function themeLoadConfig(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.prefooter` event.
     *
     * Occurs in `Theme::themefooter()` just after getting the `$maincontent`.
     * The event subject is `$this` (Theme instance) and has $maincontent as the event data
     * which you can modify with `$event->setData()` in the event handler.
     */
    public static function themePreFooter(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.postfooter` event.
     *
     * Occurs in `Theme::themefooter()` just after rendering the theme.
     * The event subject is `$this` (Theme instance) and the event data is the rendered
     * output which you can modify with `$event->setData()` in the event handler.
     */
    public static function themePostFooter(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `view.init` event.
     *
     * Occurs just before `Zikula_View#__construct()` exits. Subject is `$this`, args are
     * `array('module' => $module, 'modinfo' => $modinfo, 'themeinfo' => $themeinfo)`.
     */
    public static function viewInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `view.fetch` event.
     *
     * Filter of result of a fetch. Receives `Zikula_View` instance as subject, args are
     * `array('template' => $template)`, $data was the result of the fetch to be filtered.
     */
    public static function viewFetch(Zikula_Event $event)
    {
    }


    // users and groups

    /**
     * Listener for the `user.login.veto` event.
     *
     * Occurs immediately prior to a login that is expected to succeed.
     * (All prerequisites for a successful login have been checked and are satisfied.)
     * This event allows a module to intercept the login process and prevent a successful login from taking place.
     * This event uses `notifyUntil()`, so handlers are called until either one vetoes the login attempt,
     * or there are no more handlers for the event.
     * A handler that needs to veto a login attempt should call `setNotify()`. This will prevent other handlers
     * from receiving the event, will return to the login process, and will prevent the login from taking place.
     * A handler that vetoes a login attempt should set an appropriate error message and give any additional
     * feedback to the user attempting to log in that might be appropriate. If a handler does not
     * need to veto the login attempt, then it should simply return null (`return;` with no return value).
     *
     * Note: the user __will not__ be logged in when the event handler is executing.
     * Any attempt to check a user's permissions, his logged-in status, or any operation will
     * return a value equivalent to what an anonymous (guest) user would see.
     * Care should be taken to ensure that sensitive operations done within a handler for this event
     * do not introduce breaches of security.
     *
     *    The subject of the event will contain the user's account record, equivalent to `UserUtil::getVars($uid)`.
     *    `$event['authentication_module']` will contain the name of the module that authenticated the user.
     *    `$event['uid']` will contain the user's uid.
     */
    public static function userLoginVeto(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.login.succeeded` event.
     *
     * Occurs right after a successful attempt to log in. All handlers are notified.
     *    The event subject contains the user's user record (from `UserUtil::getVars($event['uid'])`)
     *    `$event['uid']` is the UID of the logged in user.
     *    `$event['authentication_module']` with the name of the module that authenticated.
     */
    public static function userLoginSucceeded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.login.failed` event.
     *
     * Occurs on login failure.
     * All handlers are notified. (Vetoed attempts to log in will subsequently generate this event.)
     * the subject of the event may contain the user account record of user that attempted to log in, if it
     * could be determined (e.g., it will be supplied if the login attempt failed because of a bad password,
     * but it will not be supplied if the attempt failed because the uname could not be matched with a user
     * account record).
     *     `$event['authentication_module']` with the name of the module that attempted to authenticate.
     *     `$event['uid'] may contain the uid of user that attempted to log in, if it could be determined (e.g.,
     *      it will be supplied if the login attempt failed because of a bad password, but it will not be supplied
     *      if the attempt failed because the uname could not be matched with a user account record).
     */
    public static function userLoginFailed(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.logout.succeeded` event.
     *
     * Occurs right after a successful logout.
     * All handlers are notified.
     *     The event's subject contains the user's user record
     *     `$event['uid']` is the UID of the user who logged out.
     */
    public static function userLogoutSucceeded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.logout.failed` event.
     *
     * Occurs right after a failed logout. All handlers are notified.
     *     the subject of the event will contain the user account record
     *      of the user that attempted to log out
     *     `$event['uid']` is the UID of the user who attempted to log out.
     */
    public static function userLogoutFailed(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.gettheme` event.
     *
     * This is invoked with notifyUntil so you should execute `$event->setNotified()` in the event handler.
     * Receives `$event['name']` the chosen theme name, it can modify the name.
     */
    public static function userGetTheme(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.create` event.
     *
     * Occurs after a user is created. All handlers are notified.
     * It does not apply to creation of a pending registration.
     * The full user record created is available as the subject.
     */
    public static function userCreate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.update` event.
     *
     * Occurs after a user is updated. All handlers are notified.
     * The full updated user record is available as the subject.
     */
    public static function userUpdate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.delete` event.
     *
     * Occurs after a user is deleted from the system.
     * All handlers are notified.
     * The full user record deleted is available as the subject.
     */
    public static function userDelete(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.create` event.
     *
     * Occurs after a group is created. All handlers are notified.
     * The full group record created is available as the subject.
     */
    public static function groupCreate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.update` event.
     *
     * Occurs after a group is updated. All handlers are notified.
     * The full updated group record is available as the subject.
     */
    public static function groupUpdate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.delete` event.
     *
     * Occurs after a group is deleted from the system.
     * All handlers are notified.
     * The full group record deleted is available as the subject.
     */
    public static function groupDelete(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.adduser` event.
     *
     * Occurs after a user is added to a group.
     * All handlers are notified.
     * It does not apply to pending membership requests.
     * The uid and gid are available as the subject.
     */
    public static function groupAddUser(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.removeuser` event.
     *
     * Occurs after a user is removed from a group.
     * All handlers are notified.
     * The uid and gid are available as the subject.
     */
    public static function groupRemoveUser(Zikula_Event $event)
    {
    }

    /**
     * Listener for the users.config.updated` event.
     *
     * Occurs after the Users module configuration has been
     * updated via the administration interface.
     */
    public static function usersConfigUpdated(Zikula_Event $event)
    {
    }


    // special purposes and 3rd party api support

    /**
     * Listener for pending content items.
     */
    public static function pendingContentListener(Zikula_Event $event)
    {
        if (!SecurityUtil::checkPermission('«appName()»::', '::', ACCESS_MODERATE)) {
            return;
        }
/** this is an example implementation from the Users module
        $approvalOrder = ModUtil::getVar('Users', 'moderation_order', UserUtil::APPROVAL_ANY);
        $filter = array('approved_by' => 0);
        if ($approvalOrder == UserUtil::APPROVAL_AFTER) {
            $filter['isverified'] = true;
        }
        $numPendingApproval = ModUtil::apiFunc('Users', 'registration', 'countAll', array('filter' => $filter));

        if (!empty($numPendingApproval)) {
            $collection = new Zikula_Collection_Container('Users');
            $collection->add(new Zikula_Provider_AggregateItem('registrations', __('Registrations pending approval'), $numPendingApproval, 'admin', 'viewRegistrations'));
            $event->getSubject()->add($collection);
        }
*/
    }
«ENDDEFINE»

