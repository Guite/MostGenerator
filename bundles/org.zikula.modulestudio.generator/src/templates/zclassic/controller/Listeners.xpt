«IMPORT modulestudio»
«IMPORT templates::zclassic::smallstuff»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«EXTENSION org::eclipse::xtend::util::stdlib::io»

«REM»Entry point for persistent event listeners«ENDREM»
«DEFINE Root FOR Application»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Core.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for core events.
 */
class «appName()»_Listener_Base_Core extends Zikula_AbstractBase
{
«EXPAND BaseListenersCore-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Core.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for core events.
 */
class «appName()»_Listener_Core extends «appName()»_Listener_Base_Core
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Installer.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for module installer events.
 */
class «appName()»_Listener_Base_Installer extends Zikula_AbstractBase
{
«EXPAND BaseListenersInstaller-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Installer.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for module installer events.
 */
class «appName()»_Listener_Installer extends «appName()»_Listener_Base_Installer
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/ModuleDispatch.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for dispatching modules.
 */
class «appName()»_Listener_Base_ModuleDispatch extends Zikula_AbstractBase
{
«EXPAND BaseListenersModuleDispatch-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/ModuleDispatch.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for dispatching modules.
 */
class «appName()»_Listener_ModuleDispatch extends «appName()»_Listener_Base_ModuleDispatch
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Mailer.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for mailing events.
 */
class «appName()»_Listener_Base_Mailer extends Zikula_AbstractBase
{
«EXPAND BaseListenersMailer-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Mailer.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for mailing events.
 */
class «appName()»_Listener_Mailer extends «appName()»_Listener_Base_Mailer
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Page.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for page-related events.
 */
class «appName()»_Listener_Base_Page extends Zikula_AbstractBase
{
«EXPAND BaseListenersPage-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Page.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for page-related events.
 */
class «appName()»_Listener_Page extends «appName()»_Listener_Base_Page
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Errors.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for error-related events.
 */
class «appName()»_Listener_Base_Errors extends Zikula_AbstractBase
{
«EXPAND BaseListenersErrors-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Errors.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for error-related events.
 */
class «appName()»_Listener_Errors extends «appName()»_Listener_Base_Errors
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Theme.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for theme-related events.
 */
class «appName()»_Listener_Base_Theme extends Zikula_AbstractBase
{
«EXPAND BaseListenersTheme-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Theme.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for theme-related events.
 */
class «appName()»_Listener_Theme extends «appName()»_Listener_Base_Theme
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/View.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for view-related events.
 */
class «appName()»_Listener_Base_View extends Zikula_AbstractBase
{
«EXPAND BaseListenersView-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/View.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for view-related events.
 */
class «appName()»_Listener_View extends «appName()»_Listener_Base_View
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/UserLogin.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for user login events.
 */
class «appName()»_Listener_Base_UserLogin extends Zikula_AbstractBase
{
«EXPAND BaseListenersUserLogin-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/UserLogin.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for user login events.
 */
class «appName()»_Listener_UserLogin extends «appName()»_Listener_Base_UserLogin
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/UserLogout.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for user logout events.
 */
class «appName()»_Listener_Base_UserLogout extends Zikula_AbstractBase
{
«EXPAND BaseListenersUserLogout-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/UserLogout.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for user logout events.
 */
class «appName()»_Listener_UserLogout extends «appName()»_Listener_Base_UserLogout
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/User.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for user-related events.
 */
class «appName()»_Listener_Base_User extends Zikula_AbstractBase
{
«EXPAND BaseListenersUser-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/User.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for user-related events.
 */
class «appName()»_Listener_User extends «appName()»_Listener_Base_User
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Registration.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for user registration events.
 */
class «appName()»_Listener_Base_Registration extends Zikula_AbstractBase
{
«EXPAND BaseListenersRegistration-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Registration.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for user registration events.
 */
class «appName()»_Listener_Registration extends «appName()»_Listener_Base_Registration
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Users.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for events of the Users module.
 */
class «appName()»_Listener_Base_Users extends Zikula_AbstractBase
{
«EXPAND BaseListenersUsers-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Users.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for events of the Users module.
 */
class «appName()»_Listener_Users extends «appName()»_Listener_Base_Users
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/Group.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for group-related events.
 */
class «appName()»_Listener_Base_Group extends Zikula_AbstractBase
{
«EXPAND BaseListenersGroup-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/Group.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for group-related events.
 */
class «appName()»_Listener_Group extends «appName()»_Listener_Base_Group
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listener/Base/ThirdParty.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class for special purposes and 3rd party api support.
 */
class «appName()»_Listener_Base_ThirdParty extends Zikula_AbstractBase
{
«EXPAND BaseListenersThirdParty-»
}
«ENDFILE»
«FILE getAppSourceLibPath(appName()).msconcat("Listener/ThirdParty.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class for special purposes and 3rd party api support.
 */
class «appName()»_Listener_ThirdParty extends «appName()»_Listener_Base_ThirdParty
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«ENDDEFINE»

«DEFINE BaseListenersCore FOR Application-»
    /**
     * Listener for the `api.method_not_found` event.
     *
     * Called in instances of Zikula_Api from __call().
     * Receives arguments from __call($method, argument) as $args.
     *     $event['method'] is the method which didn't exist in the main class.
     *     $event['args'] is the arguments that were passed.
     * The event subject is the class where the method was not found.
     * Must exit if $event['method'] does not match whatever the handler expects.
     * Modify $event->data and $event->setNotify().
     */
    public static function apiMethodNotFound(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.preinit` event.
     *
     * Occurs after the config.php is loaded.
     */
    public static function preInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.init` event.
     *
     * Occurs after each `System::init()` stage, `$event['stage']` contains the stage.
     * To check if the handler should execute, do `if($event['stage'] & System::CORE_STAGES_*)`.
     */
    public static function init(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.postinit` event.
     *
     * Occurs just before System::init() exits from normal execution.
     */
    public static function postInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `controller.method_not_found` event.
     *
     * Called in instances of `Zikula_Controller` from `__call()`.
     * Receives arguments from `__call($method, argument)` as `$args`.
     *    `$event['method']` is the method which didn't exist in the main class.
     *    `$event['args']` is the arguments that were passed.
     * The event subject is the class where the method was not found.
     * Must exit if `$event['method']` does not match whatever the handler expects.
     * Modify `$event->data` and `$event->setNotify()`.
     */
    public static function controllerMethodNotFound(Zikula_Event $event)
    {
        // You can have multiple of these methods.
        // See system/Modules/lib/Modules/HookUI.php for an example.
    }
«ENDDEFINE»

«DEFINE BaseListenersInstaller FOR Application-»
    /**
     * Listener for the `installer.module.installed` event.
     *
     * Called after a module is successfully installed.
     * Receives `$modinfo` as args.
     */
    public static function moduleInstalled(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `installer.module.upgraded` event.
     *
     * Called after a module is successfully upgraded.
     * Receives `$modinfo` as args.
     */
    public static function moduleUpgraded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `installer.module.uninstalled` event.
     *
     * Called after a module is successfully uninstalled.
     * Receives `$modinfo` as args.
     */
    public static function moduleUninstalled(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersModuleDispatch FOR Application-»
    /**
     * Listener for the `module_dispatch.postloadgeneric` event.
     *
     * Called after a module api or controller has been loaded.
     * Receives the args `array('modinfo' => $modinfo, 'type' => $type, 'force' => $force, 'api' => $api)`.
     */
    public static function postLoadGeneric(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.preexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     * `array('modname' => $modname, 'modfunc' => $modfunc, 'args' => $args, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`.
     */
    public static function preExecute(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.postexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     * `array('modname' => $modname, 'modfunc' => $modfunc, 'args' => $args, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`.
     * Receives the modules output with `$event->getData();`.
     * Can modify this output with `$event->setData($data);`.
     */
    public static function postExecute(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.custom_classname` event.
     *
     * In order to override the classname calculated in `ModUtil::exec()`.
     * In order to override a pre-existing controller/api method, use this event type to override the class name that is loaded.
     * This allows to override the methods using inheritance.
     * Receives no subject, args of `array('modname' => $modname, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`
     * and 'event data' of `$className`. This can be altered by setting `$event->setData()` followed by `$event->setNotified()`.
     */
    public static function customClassname(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersMailer FOR Application-»
    /**
     * Listener for the `module.mailer.api.sendmessage` event.
     *
     * Invoked from `Mailer_Api_User#sendmessage`.
     * Subject is `Mailer_Api_User` with `$args`.
     * This is a notifyUntil event so the event must `$event->setNotified()` and set any
     * return data into `$event->data`, or `$event->setData()`.
     */
    public static function sendMessage(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersPage FOR Application-»
    /**
     * Listener for the `pageutil.addvar_filter` event.
     *
     * Used to override things like system or module stylesheets or javascript.
     * Subject is the `$varname`, and `$event->data` an array of values to be modified by the filter.
     *
     * This single filter can be used to override all css or js scripts or any other var types
     * sent to `PageUtil::addVar()`.
     */
    public static function pageutilAddvarFilter(Zikula_Event $event)
    {
       // Simply test with something like
/*
       if (($key = array_search('system/Users/javascript/somescript.js', $event->data)) !== false) {
           $event->data[$key] = 'config/javascript/myoverride.js';
       }
*/
    }

    /**
     * Listener for the `system.outputfilter` event.
     *
     * Filter type event for output filter HTML sanitisation.
     */
    public static function systemOutputFilter(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersErrors FOR Application-»
    /**
     * Listener for the `setup.errorreporting` event.
     *
     * Invoked during `System::init()`.
     * Used to activate `set_error_handler()`.
     * Event must `setNotified()`.
     */
    public static function setupErrorReporting(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `systemerror` event.
     *
     * Invoked on any system error.
     * args gets `array('errorno' => $errno, 'errstr' => $errstr, 'errfile' => $errfile, 'errline' => $errline, 'errcontext' => $errcontext)`.
     */
    public static function systemError(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersTheme FOR Application-»
    /**
     * Listener for the `theme.init` event.
     *
     * Occurs just before `Theme#__construct()` exits. Subject is `$this`, args are
     * `array('theme' => $theme, 'usefilters' => $usefilters, 'themeinfo' => $themeinfo)`.
     */
    public static function init(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.load_config` event.
     *
     * Runs just before `Theme#_load_config()` completed.
     * Subject is the Theme instance.
     */
    public static function loadConfig(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.prefooter` event.
     *
     * Occurs in `Theme::themefooter()` just after getting the `$maincontent`.
     * The event subject is `$this` (Theme instance) and has $maincontent as the event data
     * which you can modify with `$event->setData()` in the event handler.
     */
    public static function preFooter(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.postfooter` event.
     *
     * Occurs in `Theme::themefooter()` just after rendering the theme.
     * The event subject is `$this` (Theme instance) and the event data is the rendered
     * output which you can modify with `$event->setData()` in the event handler.
     */
    public static function postFooter(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersView FOR Application-»
    /**
     * Listener for the `view.init` event.
     *
     * Occurs just before `Zikula_View#__construct()` exits. Subject is `$this`, args are
     * `array('module' => $module, 'modinfo' => $modinfo, 'themeinfo' => $themeinfo)`.
     */
    public static function init(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `view.fetch` event.
     *
     * Filter of result of a fetch. Receives `Zikula_View` instance as subject, args are
     * `array('template' => $template)`, $data was the result of the fetch to be filtered.
     */
    public static function fetch(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersUserLogin FOR Application-»
    /**
     * Listener for the `user.login.started` event.
     *
     * Occurs at the beginning of the log-in process, before the registration form is displayed to the user.
     *
     * NOTE: This event will not fire if the log-in process is entered through the registration process, or through
     * any other method other than visiting the log-in screen. If the user registers for a new account, 
     * the result of the registration process is a full user record, and automatic log-in after registration is enabled, 
     * then the `user.login.started` event will not fire. Likewise, if the Log-in Block is used on the site, and the user
     * initiates his log-in from that block instead of visiting the full log-in screen, then this event will not fire.
     *
     * This event will fire, however, if invalid information is provided to the Log-in block, resulting in the user being
     * redirected to the full log-in screen.
     */
    public static function started(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.login.veto` event.
     *
     * Occurs immediately prior to a login that is expected to succeed.
     * (All prerequisites for a successful login have been checked and are satisfied.)
     * This event allows a module to intercept the login process and prevent a successful login from taking place.
     * This event uses `notifyUntil()`, so handlers are called until either one vetoes the login attempt,
     * or there are no more handlers for the event.
     * A handler that needs to veto a login attempt should call `setNotify()`. This will prevent other handlers
     * from receiving the event, will return to the login process, and will prevent the login from taking place.
     * A handler that vetoes a login attempt should set an appropriate error message and give any additional
     * feedback to the user attempting to log in that might be appropriate. If a handler does not
     * need to veto the login attempt, then it should simply return null (`return;` with no return value).
     *
     * Note: the user __will not__ be logged in when the event handler is executing.
     * Any attempt to check a user's permissions, his logged-in status, or any operation will
     * return a value equivalent to what an anonymous (guest) user would see.
     * Care should be taken to ensure that sensitive operations done within a handler for this event
     * do not introduce breaches of security.
     *
     * The subject of the event will contain the user's account record, equivalent to `UserUtil::getVars($uid)`.
     * `$event['authentication_module']` will contain the name of the module that authenticated the user.
     * `$event['uid']` will contain the user's uid.
     */
    public static function veto(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.login.failed` event.
     *
     * Occurs right after a successful attempt to log in. All handlers are notified.
     * The event subject contains the user's user record (from `UserUtil::getVars($event['uid'])`) if it has been found, otherwise null.
     * The arguments of the event are as follows:
     * `'authentication_module'` an array containing the authenticating module name (`'modname'`) and method (`'method'`) 
     *   used to log the user in.
     * `'authentication_info'` an array containing the authentication information entered by the user (contents will vary by method).
     * `'redirecturl'` will initially contain an empty string. This can be modified to change where the user is redirected following the failed login.
     *
     * __The `'redirecturl'` argument__ controls where the user will be directed following a failed log-in attempt.
     * Initially, it will be an empty string, indicating that the user should continue with the log-in process and be presented
     * with the log-in form.
     *
     * If a `'redirecturl'` is specified by any entity intercepting and processing the `user.login.failed` event, then
     * the user will be redirected to the URL provided, instead of being presented with the log-in form.
     *
     * Finally, this event only fires in the event of a "normal" UI-oriented log-in attempt. A module attempting to log in
     * programmatically by directly calling `UserUtil::loginUsing()` will not see this event fired. Instead, the
     * `Users_Controller_User#login()` function can be called with the appropriate parameters, if the event is desired.
     */
    public static function failed(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.login.succeeded` event.
     *
     * Occurs right after a successful attempt to log in. All handlers are notified.
     * The event subject contains the user's user record (from `UserUtil::getVars($event['uid'])`).
     * The arguments of the event are as follows:
     *     `'authentication_module'` an array containing the authenticating module name (`'modname'`) and method (`'method'`) 
     *       used to log the user in.
     *     `'redirecturl'` will contain the value of the 'returnurl' parameter, if one was supplied, or an empty
     *       string. This can be modified to change where the user is redirected following the login.
     *
     * __The `'redirecturl'` argument__ controls where the user will be directed at the end of the log-in process.
     * Initially, it will be the value of the returnurl parameter provided to the log-in process, or blank if none was provided.
     *
     * The action following login depends on whether WCAG compliant log-in is enabled in the Users module or not. If it is enabled,
     * then the user is redirected to the returnurl immediately. If not, then the user is first displayed a log-in landing page,
     * and then meta refresh is used to redirect the user to the returnurl.
     *
     * If a `'redirecturl'` is specified by any entity intercepting and processing the `user.login.succeeded` event, then
     * the URL provided replaces the one provided by the returnurl parameter to the login process. If it is set to an empty
     * string, then the user is redirected to the site's home page.
     *
     * Finally, this event only fires in the event of a "normal" UI-oriented log-in attempt. A module attempting to log in
     * programmatically by directly calling `UserUtil::loginUsing()` will not see this event fired. Instead, the
     * `Users_Controller_User#login()` function can be called with the appropriate parameters, if the event is desired.
     */
    public static function succeeded(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersUserLogout FOR Application-»
    /**
     * Listener for the `user.logout.succeeded` event.
     *
     * Occurs right after a successful logout.
     * All handlers are notified.
     * The event's subject contains the user's user record.
     * `$event['uid']` is the UID of the user who logged out.
     */
    public static function succeeded(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersUser FOR Application-»
    /**
     * Listener for the `user.gettheme` event.
     *
     * This is invoked with notifyUntil so you should execute `$event->setNotified()` in the event handler.
     * Receives `$event['name']` the chosen theme name, it can modify the name.
     */
    public static function getTheme(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.create` event.
     *
     * Occurs after a user is created. All handlers are notified.
     * It does not apply to creation of a pending registration.
     * The full user record created is available as the subject.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the user record that was created.
     */
    public static function create(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.update` event.
     *
     * Occurs after a user is updated. All handlers are notified.
     * The full updated user record is available as the subject.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the user record, with the updated values.
     */
    public static function update(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.delete` event.
     *
     * Occurs after a user is deleted from the system.
     * All handlers are notified.
     * The full user record deleted is available as the subject.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the user record that is being deleted.
     */
    public static function delete(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersRegistration FOR Application-»
    /**
     * Listener for the `registration.started` event.
     *
     * Occurs at the beginning of the registration process, before the registration form is displayed to the user.
     */
    public static function started(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.succeeded` event.
     *
     * Occurs after a user has successfully registered a new account in the system. It will follow either a `registration.create`
     * event, or a `user.create` event, depending on the result of the registration process, the information provided by the user,
     * and several configuration options set in the Users module. The resultant record might
     * be a fully activated user record, or it might be a registration record pending approval, e-mail verification,
     * or both.
     *
     * If the registration record is a fully activated user, and the Users module is configured for automatic log-in,
     * then the system's next step (without any interaction from the user) will be the log-in process. All the customary
     * events that might fire during the log-in process could be fired at this point, including (but not limited to)
     * `user.login.veto` (which might result in the user having to perform some action in order to proceed with the 
     * log-in process), `user.login.succeeded`, and/or `user.login.failed`.
     *
     * The event's subject is set to the registration record (which might be a full user record).
     * The event's arguments are as follows:
     *     `'returnurl'` => A URL to which the user is redirected at the very end of the registration process.
     *
     * __The `'redirecturl'` argument__ controls where the user will be directed at the end of the registration process.
     * Initially, it will be blank, indicating that the default action should be taken. The default action depends on two
     * things: first, whether the result of the registration process is a registration request record or is a full user record,
     * and second, if the record is a full user record then whether automatic log-in is enabled or not.
     *
     * If the result of the registration process is a registration request record, then the default action is to direct the
     * user to a status display screen that informs him that the registration process has been completed, and also tells 
     * him what next steps are required in order to convert that request into a full user record. (The steps to be
     * taken may be out of the user's control--for example, the administrator must approve the request. The steps to
     * be taken might be within the user's control--for example, the user must verify his e-mail address. The steps might
     * be some combination of both within and outside the user's control.
     *
     * If the result of the registration process is a full user record, then one of two actions will happen by default. Either 
     * the user will be directed to the log-in screen, or the user will be automatically logged in. Which of these two occurs
     * is dependent on a module variable setting in the Users module. During the login process, one or more additional events may
     * fire.
     *
     * If a `'redirecturl'` is specified by any entity intercepting and processing the `registration.succeeded` event, then
     * __all of the above default actions are overridden__. The user will _not_ be directed to a status display screen if the result
     * of the registration process is a registration request. The user will _not_ be directed to the log-in screen, _nor_ will he
     * be automatically logged in. Instead, the user __will be directed to the URL specified in the `'redirecturl'` argument__ passed
     * back by the entity that processed the event.
     */
    public static function succeeded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.failed` event.
     *
     * Occurs after a user attempts to submit a registration request, but the request is not saved successfully.
     * The next step for the user is a page that displays the status, including any possible error messages.
     * The event subject contains null.
     * The arguments of the event are as follows:
     * `'redirecturl'` will initially contain an empty string. This can be modified to change where the user is redirected following the failed login.
     *
     * __The `'redirecturl'` argument__ controls where the user will be directed following a failed log-in attempt.
     * Initially, it will be an empty string, indicating that the user will be redirected to a page that displays status and error information.
     *
     * If a `'redirecturl'` is specified by any entity intercepting and processing the `user.login.failed` event, then
     * the user will be redirected to the URL provided, instead of being redirected to the status/error display page.
     */
    public static function failed(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.create` event.
     *
     * Occurs after a registration record is created, either through the normal user registration process, or through the 
     * administration panel for the Users module. This event will not fire if the result of the registration process is a
     * full user record. Instead, a `user.create` event will fire.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the registration record that was created.
     */
    public static function create(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.update` event.
     *
     * Occurs after a registration record is updated (likely through the admin panel, but not guaranteed).
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the registration record, with the updated values.
     */
    public static function update(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.delete` event.
     *
     * Occurs after a registration record is deleted. This could occur as a result of the administrator deleting the record 
     * through the approval/denial process, or it could happen because the registration request expired.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the registration record begin deleted.
     */
    public static function delete(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersUsers FOR Application-»
    /**
     * Listener for the users.config.updated` event.
     *
     * Occurs after the Users module configuration has been
     * updated via the administration interface.
     */
    public static function configUpdated(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersGroup FOR Application-»
    /**
     * Listener for the `group.create` event.
     *
     * Occurs after a group is created. All handlers are notified.
     * The full group record created is available as the subject.
     */
    public static function create(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.update` event.
     *
     * Occurs after a group is updated. All handlers are notified.
     * The full updated group record is available as the subject.
     */
    public static function update(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.delete` event.
     *
     * Occurs after a group is deleted from the system.
     * All handlers are notified.
     * The full group record deleted is available as the subject.
     */
    public static function delete(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.adduser` event.
     *
     * Occurs after a user is added to a group.
     * All handlers are notified.
     * It does not apply to pending membership requests.
     * The uid and gid are available as the subject.
     */
    public static function addUser(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.removeuser` event.
     *
     * Occurs after a user is removed from a group.
     * All handlers are notified.
     * The uid and gid are available as the subject.
     */
    public static function removeUser(Zikula_Event $event)
    {
    }
«ENDDEFINE»

«DEFINE BaseListenersThirdParty FOR Application-»
    /**
     * Listener for pending content items.
     */
    public static function pendingContentListener(Zikula_Event $event)
    {
        if (!SecurityUtil::checkPermission($this->name . '::', '::', ACCESS_MODERATE)) {
            return;
        }
/** this is an example implementation from the Users module
        $approvalOrder = ModUtil::getVar('Users', 'moderation_order', UserUtil::APPROVAL_ANY);
        $filter = array('approved_by' => 0);
        if ($approvalOrder == UserUtil::APPROVAL_AFTER) {
            $filter['isverified'] = true;
        }
        $numPendingApproval = ModUtil::apiFunc('Users', 'registration', 'countAll', array('filter' => $filter));

        if (!empty($numPendingApproval)) {
            $collection = new Zikula_Collection_Container('Users');
            $collection->add(new Zikula_Provider_AggregateItem('registrations', __('Registrations pending approval'), $numPendingApproval, 'admin', 'viewRegistrations'));
            $event->getSubject()->add($collection);
        }
*/
    }
«ENDDEFINE»

