«IMPORT modulestudio»
«IMPORT templates::zclassic::smallstuff»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«EXTENSION org::eclipse::xtend::util::stdlib::io»

«REM»Entry point for persistent event listeners«ENDREM»
«DEFINE Root FOR Application»
«FILE getAppSourceLibPath(appName()).msconcat("Base/Listeners.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler base class
 */
class «appName()»_Base_Listeners
{
«EXPAND BaseListeners-»
}
«ENDFILE»

«FILE getAppSourceLibPath(appName()).msconcat("Listeners.php")-»
«EXPAND FileHelper::phpFileHeader(this)-»
/**
 * Event handler implementation class.
 */
class «appName()»_Listeners extends «appName()»_Base_Listeners
{
    // here you can extend implementation of persistent event handlers
}
«ENDFILE»

«ENDDEFINE»

«DEFINE BaseListeners FOR Application-»
    // core

    /**
     * Listener for the `api.method_not_found` event.
     *
     * Called in instances of Zikula_Api from __call().
     * Receives arguments from __call($method, argument) as $args.
     *     $event['method'] is the method which didn't exist in the main class.
     *     $event['args'] is the arguments that were passed.
     * The event subject is the class where the method was not found.
     * Must exit if $event['method'] does not match whatever the handler expects.
     * Modify $event->data and $event->setNotify().
     */
    public static function coreApiMethodNotFound(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.preinit` event.
     *
     * Occurs after the config.php is loaded.
     */
    public static function corePreInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.init` event.
     *
     * Occurs after each `System::init()` stage, `$event['stage']` contains the stage.
     * To check if the handler should execute, do `if($event['stage'] & System::CORE_STAGES_*)`.
     */
    public static function coreInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `core.postinit` event.
     *
     * Occurs just before System::init() exits from normal execution.
     */
    public static function corePostInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `controller.method_not_found` event.
     *
     * Called in instances of `Zikula_Controller` from `__call()`.
     * Receives arguments from `__call($method, argument)` as `$args`.
     *    `$event['method']` is the method which didn't exist in the main class.
     *    `$event['args']` is the arguments that were passed.
     * The event subject is the class where the method was not found.
     * Must exit if `$event['method']` does not match whatever the handler expects.
     * Modify `$event->data` and `$event->setNotify()`.
     */
    public static function coreControllerMethodNotFound(Zikula_Event $event)
    {
        // You can have multiple of these methods.
        // See system/Modules/lib/Modules/HookUI.php for an example.
    }


    // modules

    /**
     * Listener for the `installer.module.installed` event.
     *
     * Called after a module is successfully installed.
     * Receives `$modinfo` as args.
     */
    public static function installerModuleInstalled(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `installer.module.upgraded` event.
     *
     * Called after a module is successfully upgraded.
     * Receives `$modinfo` as args.
     */
    public static function installerModuleUpgraded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `installer.module.uninstalled` event.
     *
     * Called after a module is successfully uninstalled.
     * Receives `$modinfo` as args.
     */
    public static function installerModuleUninstalled(Zikula_Event $event)
    {
    }


    /**
     * Listener for the `module_dispatch.postloadgeneric` event.
     *
     * Called after a module api or controller has been loaded.
     * Receives the args `array('modinfo' => $modinfo, 'type' => $type, 'force' => $force, 'api' => $api)`.
     */
    public static function moduleDispatchPostLoadGeneric(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.preexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     * `array('modname' => $modname, 'modfunc' => $modfunc, 'args' => $args, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`.
     */
    public static function moduleDispatchPreExecute(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.postexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     * `array('modname' => $modname, 'modfunc' => $modfunc, 'args' => $args, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`.
     * Receives the modules output with `$event->getData();`.
     * Can modify this output with `$event->setData($data);`.
     */
    public static function moduleDispatchPostExecute(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module_dispatch.custom_classname` event.
     *
     * In order to override the classname calculated in `ModUtil::exec()`.
     * In order to override a pre-existing controller/api method, use this event type to override the class name that is loaded.
     * This allows to override the methods using inheritance.
     * Receives no subject, args of `array('modname' => $modname, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`
     * and 'event data' of `$className`. This can be altered by setting `$event->setData()` followed by `$event->setNotified()`.
     */
    public static function moduleDispatchCustomClassname(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `module.mailer.api.sendmessage` event.
     *
     * Invoked from `Mailer_Api_User#sendmessage`.
     * Subject is `Mailer_Api_User` with `$args`.
     * This is a notifyUntil event so the event must `$event->setNotified()` and set any
     * return data into `$event->data`, or `$event->setData()`.
     */
    public static function moduleMailerApiSendmessage(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `pageutil.addvar_filter` event.
     *
     * Used to override things like system or module stylesheets or javascript.
     * Subject is the `$varname`, and `$event->data` an array of values to be modified by the filter.
     *
     * This single filter can be used to override all css or js scripts or any other var types
     * sent to `PageUtil::addVar()`.
     */
    public static function pageutilAddvarFilter(Zikula_Event $event)
    {
       // Simply test with something like
/*
       if (($key = array_search('system/Users/javascript/somescript.js', $event->data)) !== false) {
           $event->data[$key] = 'config/javascript/myoverride.js';
       }
*/
    }


    // errors

    /**
     * Listener for the `setup.errorreporting` event.
     *
     * Invoked during `System::init()`.
     * Used to activate `set_error_handler()`.
     * Event must `setNotified()`.
     */
    public static function setupErrorReporting(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `system.outputfilter` event.
     *
     * Filter type event for output filter HTML sanitisation.
     */
    public static function systemOutputFilter(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `systemerror` event.
     *
     * Invoked on any system error.
     * args gets `array('errorno' => $errno, 'errstr' => $errstr, 'errfile' => $errfile, 'errline' => $errline, 'errcontext' => $errcontext)`.
     */
    public static function systemError(Zikula_Event $event)
    {
    }


    // themes and views

    /**
     * Listener for the `theme.init` event.
     *
     * Occurs just before `Theme#__construct()` exits. Subject is `$this`, args are
     * `array('theme' => $theme, 'usefilters' => $usefilters, 'themeinfo' => $themeinfo)`.
     */
    public static function themeInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.load_config` event.
     *
     * Runs just before `Theme#_load_config()` completed.
     * Subject is the Theme instance.
     */
    public static function themeLoadConfig(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.prefooter` event.
     *
     * Occurs in `Theme::themefooter()` just after getting the `$maincontent`.
     * The event subject is `$this` (Theme instance) and has $maincontent as the event data
     * which you can modify with `$event->setData()` in the event handler.
     */
    public static function themePreFooter(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `theme.postfooter` event.
     *
     * Occurs in `Theme::themefooter()` just after rendering the theme.
     * The event subject is `$this` (Theme instance) and the event data is the rendered
     * output which you can modify with `$event->setData()` in the event handler.
     */
    public static function themePostFooter(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `view.init` event.
     *
     * Occurs just before `Zikula_View#__construct()` exits. Subject is `$this`, args are
     * `array('module' => $module, 'modinfo' => $modinfo, 'themeinfo' => $themeinfo)`.
     */
    public static function viewInit(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `view.fetch` event.
     *
     * Filter of result of a fetch. Receives `Zikula_View` instance as subject, args are
     * `array('template' => $template)`, $data was the result of the fetch to be filtered.
     */
    public static function viewFetch(Zikula_Event $event)
    {
    }


    // user

    /**
     * Listener for the `user.login.started` event.
     *
     * Occurs at the beginning of the log-in process, before the registration form is displayed to the user.
     *
     * NOTE: This event will not fire if the log-in process is entered through the registration process, or through
     * any other method other than visiting the log-in screen. If the user registers for a new account, 
     * the result of the registration process is a full user record, and automatic log-in after registration is enabled, 
     * then the `user.login.started` event will not fire. Likewise, if the Log-in Block is used on the site, and the user
     * initiates his log-in from that block instead of visiting the full log-in screen, then this event will not fire.
     *
     * This event will fire, however, if invalid information is provided to the Log-in block, resulting in the user being
     * redirected to the full log-in screen.
     */
    public static function userLoginStarted(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.login.veto` event.
     *
     * Occurs immediately prior to a login that is expected to succeed.
     * (All prerequisites for a successful login have been checked and are satisfied.)
     * This event allows a module to intercept the login process and prevent a successful login from taking place.
     * This event uses `notifyUntil()`, so handlers are called until either one vetoes the login attempt,
     * or there are no more handlers for the event.
     * A handler that needs to veto a login attempt should call `setNotify()`. This will prevent other handlers
     * from receiving the event, will return to the login process, and will prevent the login from taking place.
     * A handler that vetoes a login attempt should set an appropriate error message and give any additional
     * feedback to the user attempting to log in that might be appropriate. If a handler does not
     * need to veto the login attempt, then it should simply return null (`return;` with no return value).
     *
     * Note: the user __will not__ be logged in when the event handler is executing.
     * Any attempt to check a user's permissions, his logged-in status, or any operation will
     * return a value equivalent to what an anonymous (guest) user would see.
     * Care should be taken to ensure that sensitive operations done within a handler for this event
     * do not introduce breaches of security.
     *
     * The subject of the event will contain the user's account record, equivalent to `UserUtil::getVars($uid)`.
     * `$event['authentication_module']` will contain the name of the module that authenticated the user.
     * `$event['uid']` will contain the user's uid.
     */
    public static function userLoginVeto(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.login.succeeded` event.
     *
     * Occurs right after a successful attempt to log in. All handlers are notified.
     * The event subject contains the user's user record (from `UserUtil::getVars($event['uid'])`).
     * The arguments of the event are as follows:
     *     `'authentication_module'` an array containing the authenticating module name (`'modname'`) and method (`'method'`) 
     *       used to log the user in.
     *     `'redirecturl'` will contain the value of the 'returnurl' parameter, if one was supplied, or an empty
     *       string. This can be modified to change where the user is redirected following the login.
     *
     * __The `'redirecturl'` argument__ controls where the user will be directed at the end of the log-in process.
     * Initially, it will be the value of the returnurl parameter provided to the log-in process, or blank if none was provided.
     *
     * The action following login depends on whether WCAG compliant log-in is enabled in the Users module or not. If it is enabled,
     * then the user is redirected to the returnurl immediately. If not, then the user is first displayed a log-in landing page,
     * and then meta refresh is used to redirect the user to the returnurl.
     *
     * If a `'redirecturl'` is specified by any entity intercepting and processing the `user.login.succeeded` event, then
     * the URL provided replaces the one provided by the returnurl parameter to the login process. If it is set to an empty
     * string, then the user is redirected to the site's home page.
     *
     * Finally, this event only fires in the event of a "normal" UI-oriented log-in attempt. A module attempting to log in
     * programmatically by directly calling `UserUtil::loginUsing()` will not see this event fired. Instead, the
     * `Users_Controller_User#login()` function can be called with the appropriate parameters, if the event is desired.
     */
    public static function userLoginSucceeded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.logout.succeeded` event.
     *
     * Occurs right after a successful logout.
     * All handlers are notified.
     * The event's subject contains the user's user record.
     * `$event['uid']` is the UID of the user who logged out.
     */
    public static function userLogoutSucceeded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.gettheme` event.
     *
     * This is invoked with notifyUntil so you should execute `$event->setNotified()` in the event handler.
     * Receives `$event['name']` the chosen theme name, it can modify the name.
     */
    public static function userGetTheme(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.create` event.
     *
     * Occurs after a user is created. All handlers are notified.
     * It does not apply to creation of a pending registration.
     * The full user record created is available as the subject.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the user record that was created.
     */
    public static function userCreate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.update` event.
     *
     * Occurs after a user is updated. All handlers are notified.
     * The full updated user record is available as the subject.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the user record, with the updated values.
     */
    public static function userUpdate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.delete` event.
     *
     * Occurs after a user is deleted from the system.
     * All handlers are notified.
     * The full user record deleted is available as the subject.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the user record that is being deleted.
     */
    public static function userDelete(Zikula_Event $event)
    {
    }


    // registration

    /**
     * Listener for the `registration.started` event.
     *
     * Occurs at the beginning of the registration process, before the registration form is displayed to the user.
     */
    public static function registrationStarted(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `user.registration.succeeded` event.
     *
     * Occurs after a user has successfully registered a new account in the system. It will follow either a `registration.create`
     * event, or a `user.create` event, depending on the result of the registration process, the information provided by the user,
     * and several configuration options set in the Users module. The resultant record might
     * be a fully activated user record, or it might be a registration record pending approval, e-mail verification,
     * or both.
     *
     * If the registration record is a fully activated user, and the Users module is configured for automatic log-in,
     * then the system's next step (without any interaction from the user) will be the log-in process. All the customary
     * events that might fire during the log-in process could be fired at this point, including (but not limited to)
     * `user.login.veto` (which might result in the user having to perform some action in order to proceed with the 
     * log-in process), `user.login.succeeded`, and/or `user.login.failed`.
     *
     * The event's subject is set to the registration record (which might be a full user record).
     * The event's arguments are as follows:
     *     `'returnurl'` => A URL to which the user is redirected at the very end of the registration process.
     *
     * __The `'redirecturl'` argument__ controls where the user will be directed at the end of the registration process.
     * Initially, it will be blank, indicating that the default action should be taken. The default action depends on two
     * things: first, whether the result of the registration process is a registration request record or is a full user record,
     * and second, if the record is a full user record then whether automatic log-in is enabled or not.
     *
     * If the result of the registration process is a registration request record, then the default action is to direct the
     * user to a status display screen that informs him that the registration process has been completed, and also tells 
     * him what next steps are required in order to convert that request into a full user record. (The steps to be
     * taken may be out of the user's control--for example, the administrator must approve the request. The steps to
     * be taken might be within the user's control--for example, the user must verify his e-mail address. The steps might
     * be some combination of both within and outside the user's control.
     *
     * If the result of the registration process is a full user record, then one of two actions will happen by default. Either 
     * the user will be directed to the log-in screen, or the user will be automatically logged in. Which of these two occurs
     * is dependent on a module variable setting in the Users module. During the login process, one or more additional events may
     * fire.
     *
     * If a `'redirecturl'` is specified by any entity intercepting and processing the `registration.succeeded` event, then
     * __all of the above default actions are overridden__. The user will _not_ be directed to a status display screen if the result
     * of the registration process is a registration request. The user will _not_ be directed to the log-in screen, _nor_ will he
     * be automatically logged in. Instead, the user __will be directed to the URL specified in the `'redirecturl'` argument__ passed
     * back by the entity that processed the event.
     */
    public static function registrationSucceeded(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.failed` event.
     *
     * Occurs after a user attempts to submit a registration request, but the request is not saved successfully.
     * The next step for the user is a page that displays the status, including any possible error messages.
     */
    public static function registrationFailed(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.create` event.
     *
     * Occurs after a registration record is created, either through the normal user registration process, or through the 
     * administration panel for the Users module. This event will not fire if the result of the registration process is a
     * full user record. Instead, a `user.create` event will fire.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the registration record that was created.
     */
    public static function registrationCreate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.update` event.
     *
     * Occurs after a registration record is updated (likely through the admin panel, but not guaranteed).
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the registration record, with the updated values.
     */
    public static function registrationUpdate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `registration.delete` event.
     *
     * Occurs after a registration record is deleted. This could occur as a result of the administrator deleting the record 
     * through the approval/denial process, or it could happen because the registration request expired.
     * This is a storage-level event, not a UI event. It should not be used for UI-level actions such as redirects.
     * The subject of the event is set to the registration record begin deleted.
     */
    public static function registrationDelete(Zikula_Event $event)
    {
    }


    // users module

    /**
     * Listener for the users.config.updated` event.
     *
     * Occurs after the Users module configuration has been
     * updated via the administration interface.
     */
    public static function usersConfigUpdated(Zikula_Event $event)
    {
    }


    // group

    /**
     * Listener for the `group.create` event.
     *
     * Occurs after a group is created. All handlers are notified.
     * The full group record created is available as the subject.
     */
    public static function groupCreate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.update` event.
     *
     * Occurs after a group is updated. All handlers are notified.
     * The full updated group record is available as the subject.
     */
    public static function groupUpdate(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.delete` event.
     *
     * Occurs after a group is deleted from the system.
     * All handlers are notified.
     * The full group record deleted is available as the subject.
     */
    public static function groupDelete(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.adduser` event.
     *
     * Occurs after a user is added to a group.
     * All handlers are notified.
     * It does not apply to pending membership requests.
     * The uid and gid are available as the subject.
     */
    public static function groupAddUser(Zikula_Event $event)
    {
    }

    /**
     * Listener for the `group.removeuser` event.
     *
     * Occurs after a user is removed from a group.
     * All handlers are notified.
     * The uid and gid are available as the subject.
     */
    public static function groupRemoveUser(Zikula_Event $event)
    {
    }


    // special purposes and 3rd party api support

    /**
     * Listener for pending content items.
     */
    public static function pendingContentListener(Zikula_Event $event)
    {
        if (!SecurityUtil::checkPermission('«appName()»::', '::', ACCESS_MODERATE)) {
            return;
        }
/** this is an example implementation from the Users module
        $approvalOrder = ModUtil::getVar('Users', 'moderation_order', UserUtil::APPROVAL_ANY);
        $filter = array('approved_by' => 0);
        if ($approvalOrder == UserUtil::APPROVAL_AFTER) {
            $filter['isverified'] = true;
        }
        $numPendingApproval = ModUtil::apiFunc('Users', 'registration', 'countAll', array('filter' => $filter));

        if (!empty($numPendingApproval)) {
            $collection = new Zikula_Collection_Container('Users');
            $collection->add(new Zikula_Provider_AggregateItem('registrations', __('Registrations pending approval'), $numPendingApproval, 'admin', 'viewRegistrations'));
            $event->getSubject()->add($collection);
        }
*/
    }
«ENDDEFINE»

