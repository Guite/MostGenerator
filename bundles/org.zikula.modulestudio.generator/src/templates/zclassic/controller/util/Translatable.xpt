«IMPORT modulestudio»
«IMPORT templates::zclassic::smallstuff»
«EXTENSION extensions::Utils»
«REM»EXTENSION org::eclipse::xtend::util::stdlib::io»«ENDREM»

«REM»start point for the Util class creation«ENDREM»
«DEFINE Root FOR Application»
    «FILE getAppSourceLibPath(appName()).msconcat("Util/Base/I18n.php")»«EXPAND FileHelper::phpFileHeader(this)»«EXPAND TranslatableFunctionsBase-»«ENDFILE»
    «FILE getAppSourceLibPath(appName()).msconcat("Util/I18n.php")»«EXPAND FileHelper::phpFileHeader(this)»«EXPAND TranslatableFunctionsImpl-»«ENDFILE»
«ENDDEFINE»

«DEFINE TranslatableFunctionsBase FOR Application-»
/**
 * Utility base class for i18n helper methods.
 */
class «appName()»_Util_Base_I18n extends Zikula_AbstractBase
{
    /**
     * Return list of i18n fields per entity.
     * These are required to be determined to recognize
     * that they have to be selected from according translation tables.
     */
    public static function getI18nFields($objectType)
    {
        $fields = array();
        switch ($objectType) {
«EXPAND TranslatableFieldList FOREACH getI18nEntities()-»
        }
        return $fields;
    }

    /**
     * Post-processing method copying best fitting translation to main fields.
     * Cares for compatibility to processing entities without i18n behaviour.
     */
    public static function prepareEntityForOutput($objectType, $data)
    {
        if (!$data) {
            return $data;
        }

        $fields = self::getI18nFields($objectType);
        if (!count($fields)) {
            return $data;
        }

        $useObject = (is_object($data) && $data instanceOf Doctrine_Record);

        // set default values
        foreach ($fields as $field) {
            if ($useObject) {
                $data->mapValue($field['name'], $field['default']);
            } else {
                $data[$field['name']] = $field['default'];
            }
        }

        // determine supported locales
        $supportedLocales = ZLanguage::getInstalledLanguages();
        $currentLanguage = ZLanguage::getLanguageCode();
        $defaultLanguage = System::getVar('language_i18n', 'en');

        // read according translation, fall back to default language
        if (isset($data['Translation']) && (isset($data['Translation'][$currentLanguage]) || isset($data['Translation'][$defaultLanguage]))) {
            $lang = (in_array($currentLanguage, $supportedLocales) && isset($data['Translation'][$currentLanguage])) ? $currentLanguage : $defaultLanguage;
            foreach ($fields as $field) {
                $value = isset($data['Translation'][$lang][$field['name']]) ? $data['Translation'][$lang][$field['name']] : '';
                if ($useObject) {
                    $data->mapValue($field['name'], $value);
                } else {
                    $data[$field['name']] = $value;
                }
            }
        }
        return $data;
    }

    /**
     * Post-processing method copying all translations to main fields.
     * This ensures easy compatibility to the Forms plugins where it
     * it is not possible yet to define sub arrays in the group attribute.
     */
    public static function prepareEntityForEdit($objectType, $data)
    {
        if (!$data) {
            return $data;
        }

        $fields = self::getI18nFields($objectType);
        if (!count($fields)) {
            return $data;
        }

        foreach ($fields as $field) {
            if (isset($data[$field['name']])) {
                unset($data[$field['name']]);
            }
        }

        $useOnlyCurrentLocale = true;
        if (System::getVar('multilingual') == 1) {
            $useOnlyCurrentLocale = false;
            $lang = ZLanguage::getLanguageCode();
            foreach ($supportedLocales as $locale) {
                foreach ($fields as $field) {
                    $data[$field['name'] . $locale] = isset($data['Translation'][$locale]) ? $data['Translation'][$locale][$field['name']] : '';
                }
            }
        }
        if ($useOnlyCurrentLocale === true) {
            $locale = ZLanguage::getLanguageCode();
            foreach ($fields as $field) {
                $data[$field['name'] . $locale] = isset($data['Translation'][$locale]) ? $data['Translation'][$locale][$field['name']] : '';
            }
        }
        return $data;
    }

    /**
     * Post-editing method copying all translated fields back to their subarrays.
     * This ensures easy compatibility to the Forms plugins where it
     * it is not possible yet to define sub arrays in the group attribute.
     */
    public static function processEntityAfterEdit($objectType, $record, $formData)
    {
        if (!$formData) {
            return $data;
        }

        $fields = self::getI18nFields($objectType);
        if (!count($fields)) {
            return $formData;
        }

        $useOnlyCurrentLocale = true;
        if (System::getVar('multilingual') == 1) {
            $useOnlyCurrentLocale = false;
            $lang = ZLanguage::getLanguageCode();
            foreach ($supportedLocales as $locale) {
                foreach ($fields as $field) {
                    $record->Translation[$locale]->$field['name'] = isset($formData[$field['name'] . $locale]) ? $formData[$field['name'] . $locale] : '';
                    unset($formData[$field['name'] . $locale]);
                }
            }
        }
        if ($useOnlyCurrentLocale === true) {
            $locale = ZLanguage::getLanguageCode();
            foreach ($fields as $field) {
                $record->Translation[$locale]->$field['name'] = isset($formData[$field['name'] . $locale]) ? $formData[$field['name'] . $locale] : '';
                unset($formData[$field['name'] . $locale]);
            }
        }
        return $formData;
    }
}
«ENDDEFINE»

«DEFINE TranslatableFieldList FOR Entity-»
            case '«name.formatForCode()»':
                $fields = array(
«EXPAND TranslatableFieldDefinition(i18nFields.split(", "))-»
                );
                break;
«ENDDEFINE»

«DEFINE TranslatableFieldDefinition(List fieldNames) FOR Entity-»
«EXPAND TranslatableFieldDefinition(fieldNames) FOREACH fields SEPARATOR ','»
«ENDDEFINE»

«DEFINE TranslatableFieldDefinition(List fieldNames) FOR EntityField-»
«REM»error("Error: undefined entity field type " + metaType.toString() + " (code 542324)") -> ""-»«ENDREM»
«ENDDEFINE»

«DEFINE TranslatableFieldDefinition(List fieldNames) FOR DerivedField-»
«IF !fieldNames.select(a|a == actualFieldName()).isEmpty-»
                    array('name'    => '«actualFieldName()»',
                          'default' => '«IF defaultValue != ''-»«defaultValue»«ELSE-»«actualFieldName().formatForDisplayCapital()»«ENDIF-»'),
«ENDIF-»
«ENDDEFINE»

«DEFINE TranslatableFieldDefinition(List fieldNames) FOR CalculatedField-»
«IF !fieldNames.select(a|a == actualFieldName()).isEmpty-»
                    array('name'    => '«actualFieldName()»',
                          'default' => '«actualFieldName().formatForDisplayCapital()»'),
«ENDIF-»
«ENDDEFINE»

«DEFINE TranslatableFunctionsImpl FOR Application-»
/**
 * Utility implementation class for i18n helper methods.
 */
class «appName()»_Util_I18n extends «appName()»_Util_Base_I18n
{
    // feel free to add your own convenience methods here
}
«ENDDEFINE»
