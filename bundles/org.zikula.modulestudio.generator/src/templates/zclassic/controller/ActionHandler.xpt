«IMPORT modulestudio»
«REM«IMPORT templates::zclassic::smallstuff»«ENDREM»
«EXTENSION extensions::Utils»
«EXTENSION extensions::ClassUtils»
«REMEXTENSION org::eclipse::xtend::util::stdlib::io»«ENDREM»

«REM»Entry point for Form handler classes«ENDREM»
«DEFINE Root FOR Application-»
    «EXPAND Root(this) FOREACH getEditActions()-»
«EXPAND templates::zclassic::controller::actionHandler::Config::Root-»
«ENDDEFINE»

«DEFINE Root(Application app) FOR Action-»
    «EXPAND Root(app, controller, 'edit') FOREACH app.models.entities-»
«ENDDEFINE»


«DEFINE FormCreate(String appName, Controller controller, String actionName) FOR Action-»
    // Create new Form reference
    $view = FormUtil::newForm('«appName.formatForCode()»', $this);

«LET formatForCode(appName.msconcat("_Form_Handler_").msconcat(prepClassPart(controller.name)).msconcat(prepClassPart(actionName))) AS controllerPraefix-»

    // Execute form using supplied template and page event handler
    return $view->execute('«controllerPraefix».tpl', new «controllerPraefix»());
«ENDLET-»
«ENDDEFINE»


«REM»Entry point for Form handler classes«ENDREM»
«DEFINE Root(Application app, Controller controller, String actionName) FOR Entity-»
«info("Generating \"" + controller.name + "\" form handler classes for \"" + name + "_" + actionName + "\"") -> ""-»
«FILE getAppSourcePath(app.appName()).msconcat(baseClassFormHandler(controller, name, actionName).asFile())»
«EXPAND FileHelper::phpFileHeader(app)-»
«EXPAND FormHandlerBaseImpl(app, controller, actionName)-»
«ENDFILE»
«FILE getAppSourcePath(app.appName()).msconcat(implClassFormHandler(controller, name, actionName).asFile())»
«EXPAND FileHelper::phpFileHeader(app)-»
«EXPAND FormHandlerImpl(app, controller, actionName)-»
«ENDFILE»
«ENDDEFINE»


«REM»base implementation«ENDREM»
«DEFINE FormHandlerBaseImpl(Application app, Controller controller, String actionName) FOR Entity-»
/**
 * This handler class handles the page events of the Form called by the «formatForCode(app.appName().msconcat("_").msconcat(controller.name()).msconcat("_").msconcat(actionName))»() function.
 * It aims on the «name.formatForDisplay()» object type.
 *
 * Member variables in a form handler object are persisted accross different page requests. This means
 * a member variable $this->X can be set on one request and on the next request it will still contain
 * the same value.
 *
 * A form handler will be notified of various events that happens during it's life-cycle.
 * When a specific event occurs then the corresponding event handler (class method) will be executed. Handlers
 * are named exactly like their events - this is how the framework knows which methods to call.
 *
 * The list of events is:
 *
 * - <b>initialize</b>: this event fires before any of the events for the plugins and can be used to setup
 *   the form handler. The event handler typically takes care of reading URL variables, access control
 *   and reading of data from the database.
 *
 * - <b>handleCommand</b>: this event is fired by various plugins on the page. Typically it is done by the
 *   Zikula_Form_Plugin_Button plugin to signal that the user activated a button.
 */
class «baseClassFormHandler(controller, name, actionName)» extends Zikula_Form_AbstractHandler
{
    /**
     * Persistent member vars
     */

    // id of «name.formatForDisplay()»
    protected $«idField()»;

    // create or edit
    protected $mode;

    // treated object type
    protected $objectType;

    // code for redirect after command handling
    protected $returnTo = null;

    // url of current form with all parameters for multiple creations
    protected $repeatReturnUrl = null;

    // whether this form is being used inline
    protected $inlineUsage = false;

    // full prefix for related items
    protected $idPrefix = '';

    /**
     * Post construction hook.
     *
     * @return mixed
     */
    public function setup()
    {
    }

«EXPAND initialize(app, controller, actionName)-»

    /**
     * Method stub for own additions in subclasses.
     */
    protected function initializeAdditions()
    {
    }

    /**
     * Pre-initialise hook.
     *
     * @return void
     */
    public function preInitialize()
    {
    }

    /**
     * Post-initialise hook.
     *
     * @return void
     */
    public function postInitialize()
    {
    }

«EXPAND getRedirectCodes(app, controller, actionName)-»

«EXPAND getDefaultReturnUrl(app, controller, actionName)-»

«EXPAND handleCommand(app, controller, actionName)-»

«EXPAND getRedirectUrl(app, controller, actionName)-»

«EXPAND retrieveRelatedObjects(app, controller)-»

    /**
     * Helper method for updating links to related records.
     */
    protected function updateRelationLinks($entity)
    {
«EXPAND UpdateRelationLinks(true) FOREACH incoming.typeSelect(ManyToManyRelationship)-»
«EXPAND UpdateRelationLinks(false) FOREACH outgoing.typeSelect(JoinRelationship)-»
    }

«IF hasUploadFields()-»

«EXPAND handleUploads(app)-»
«ENDIF-»
}
«ENDDEFINE»


«REM»concrete implementation stub«ENDREM»
«DEFINE FormHandlerImpl(Application app, Controller controller, String actionName) FOR Entity-»
/**
 * This handler class handles the page events of the Form called by the «formatForCode(app.appName().msconcat("_").msconcat(controller.name()).msconcat("_").msconcat(actionName))»() function.
 * It aims on the «name.formatForDisplay()» object type.
 */
class «implClassFormHandler(controller, name, actionName)» extends «baseClassFormHandler(controller, name, actionName)»
{
    // feel free to extend the base handler class here
}
«ENDDEFINE»

«DEFINE initialize(Application app, Controller controller, String actionName) FOR Entity-»
    /**
     * Initialize form handler.
     *
     * This method takes care of all necessary initialisation of our data and form states.
     *
     * @return boolean False in case of initialization errors, otherwise true.
     */
    public function initialize(Zikula_Form_View $view)
    {
        $this->inlineUsage = ((UserUtil::getTheme() == 'Printer') ? true : false);
        $this->idPrefix = $this->request->getGet()->filter('idp', '', FILTER_SANITIZE_STRING);

        // retrieve the ID of the object we wish to edit
        // default to 0 (which is a numeric id but an invalid value)
        // no provided id means that we want to create a new object
        $this->«idField()» = (int) $this->request->getGet()->filter('«idField()»', 0, FILTER_VALIDATE_INT);
        if (!$this->«idField()») {
            $this->«idField()» = (int) $this->request->getGet()->filter('id', 0, FILTER_VALIDATE_INT);
        }

        $this->objectType = '«name.formatForCode()»';

        // initialise redirect goal
        $this->returnTo = $this->request->getGet()->filter('returnTo', null, FILTER_SANITIZE_STRING);
        // store current uri for repeated creations
        $this->repeatReturnUrl = System::getCurrentURI();

        $entityClass = '«appName()»_Entity_' . ucfirst($this->objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        $entity = null;
        $this->mode = 'create';

        // if «idField()» is not 0, we wish to edit an existing «name.formatForDisplay()»
        if ($this->«idField()») {
            $this->mode = 'edit';

            if (!SecurityUtil::checkPermission('«app.appName()»:«name.formatForCodeCapital()»:', '::', ACCESS_EDIT)) {
                // set an error message and return false
                return $this->view->registerError(LogUtil::registerPermissionError());
            }

            $idField = '«idField()»';
«EXPAND ControllerHelper::retrieveEntityFromModel('idField', "this->" + idField(), true)-»

            // try to guarantee that only one person at a time can be editing this «name.formatForDisplay()»
            $returnUrl = ModUtil::url('«app.appName()»', '«controller.name()»', 'display', array('ot' => $this->objectType, '«idField()»' => $this->«idField()»));
            ModUtil::apiFunc('PageLock', 'user', 'pageLock',
                                 array('lockName' => '«app.appName()»«name.formatForCodeCapital()»' . $this->«idField()»,
                                       'returnUrl' => $returnUrl));
        }
        else {
            if (!SecurityUtil::checkPermission('«app.appName()»:«name.formatForCodeCapital()»:', '::', ACCESS_ADD)) {
                return $this->view->registerError(LogUtil::registerPermissionError());
            }

            $template«idField().toFirstUpper()» = (int) $this->request->getGet()->filter('astemplate', 0, FILTER_VALIDATE_INT);
            if ($template«idField().toFirstUpper()» > 0) {
                // reuse existing «name.formatForDisplay()»
                $idField = '«idField()»';
«EXPAND ControllerHelper::retrieveEntityFromModel('idField', "template" + idField().toFirstUpper(), true)-»
                //$entity['«idField()»'] = null;
            }
            else {
                $entity = new $entityClass();

«EXPAND InitRelatedObjectDefault(true) FOREACH incoming.typeSelect(JoinRelationship)-»
«EXPAND InitRelatedObjectDefault(false) FOREACH outgoing.typeSelect(JoinRelationship)-»
            }
        }
«FOREACH fields.typeSelect(DateField) AS dateField-»

        if ($entity['«dateField.name.formatForCode()»'] == '1900-01-01 00:00:00') {
            $entity['«dateField.name.formatForCode()»'] = null;
        }
«ENDFOREACH-»
«IF hasTranslatableFields()-»

        // process translated fields
        AdShare_Util_Translatable::prepareEntityForEdit($this->objectType, $entity);
«ENDIF-»

        // assign data to template
        $this->view->assign('«name.formatForDB()»', $entity)
                   ->assign('mode', $this->mode)
                   ->assign('inlineUsage', $this->inlineUsage);

        $this->initializeAdditions();

        // everything okay, no initialization errors occured
        return true;
    }
«ENDDEFINE»


«DEFINE InitRelatedObjectDefault(Boolean incoming) FOR JoinRelationship-»
«LET getRelationAliasName(!incoming).formatForCodeCapital() AS relationAliasName-»
«LET (!(incoming && this.metaType != ManyToManyRelationship || this.metaType == OneToOneRelationship)) AS many-»
                $entity['«relationAliasName»'] = $this->retrieveRelatedObjects('«((incoming) ? source : target).name.formatForCode()»', '«relationAliasName.formatForDB()»', «IF !many»false«ELSE»true«ENDIF»);
«ENDLET-»
«ENDLET-»
«ENDDEFINE»

«DEFINE retrieveRelatedObjects(Application app, Controller controller) FOR Entity-»
    /**
     * Select a related object in create mode.
     *
     * @return array Single result or list of results.
     */
    protected function retrieveRelatedObjects($objectType, $relationInputFieldName, $many = false, $source = 'GET')
    {
        $entityClass = '«appName()»_Entity_' . ucfirst($this->objectType);
        $repository = $this->entityManager->getRepository($entityClass);

«REM»TODO: retrieve id field name otherwise, and support composite keys«ENDREM»
        $objectTemp = new $entityClass(); 
        $idField = $objectTemp->get_idField();

        $where = '';
        $sortParam = $repository->getDefaultSortingField() . ' asc';
        if ($many) {
            $inputValue = '';
            if ($source == 'POST') {
                $inputValue = $this->request->getPost()->get($relationInputFieldName, '');
            }
            else {
                $inputValue = $this->request->getGet()->get($relationInputFieldName, '');
            }
            if (empty($inputValue)) {
                return array();
            }

            $where = $idField . ' IN (' . DataUtil::formatForStore($inputValue) . ')';
        }
        else {
            $inputValue = 0;
            if ($source == 'POST') {
                $inputValue = $this->request->getPost()->filter($relationInputFieldName, 0, FILTER_VALIDATE_INT);
            }
            else {
                $inputValue = $this->request->getGet()->filter($relationInputFieldName, 0, FILTER_VALIDATE_INT);
            }
            if ($inputValue == 0) {
                return 0;
            }

            $where = $idField . ' = \'' . DataUtil::formatForStore($inputValue) . '\'';
        }
        list($result, $resultCount) = $repository->selectWherePaginated($where, $sortParam, 1, 50);
        return (($many) ? $result : $result[0]);
    }
«ENDDEFINE»

«DEFINE getRedirectCodes(Application app, Controller controller, String actionName) FOR Entity-»
    /**
     * Get list of allowed redirect codes.
     */
    protected function getRedirectCodes()
    {
        $codes = array();
«FOREACH app.controllers.controllers AS someController-»
«LET someController.name() AS controllerName-»
«IF someController.hasActions('main')-»
        // main page of «controllerName» area
        $codes[] = '«controllerName»';
«ENDIF-»
«IF someController.hasActions('view')-»
        // «controllerName» list of «nameMultiple.formatForDisplay()»
        $codes[] = '«someController.name()»View';
«ENDIF-»
«IF someController.hasActions('display')-»
        // «controllerName» display page of treated «name.formatForDisplay()»
        $codes[] = '«controllerName»Display';
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
«FOREACH incoming.select(e|e.metaType == OneToOneRelationship || e.metaType == OneToManyRelationship) AS incomingRelation-»
«LET incomingRelation.source AS sourceEntity-»
«IF sourceEntity.name != this.name-»
«FOREACH app.controllers.controllers AS someController-»
«LET someController.name() AS controllerName-»
«IF someController.hasActions('view')-»
        // «controllerName» list of «sourceEntity.nameMultiple.formatForDisplay()»
        $codes[] = '«controllerName»View«sourceEntity.name.formatForCodeCapital()»';
«ENDIF-»
«IF someController.hasActions('display')-»
        // «controllerName» display page of treated «sourceEntity.name.formatForDisplay()»
        $codes[] = '«controllerName»Display«sourceEntity.name.formatForCodeCapital()»';
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
        return $codes;
    }
«ENDDEFINE»

«DEFINE getDefaultReturnUrl(Application app, Controller controller, String actionName) FOR Entity-»
    /**
     * Get the default redirect url. Required if no returnTo parameter has been supplied.
     * This method is called in handleCommand so we know which command has been performed.
     */
    protected function getDefaultReturnUrl($args, $obj)
    {
«IF controller.hasActions('view')-»
        // redirect to the list of «nameMultiple.formatForCode()»
        $viewArgs = array('ot' => $this->objectType);
«IF tree != EntityTreeType::NONE-»
        $viewArgs['tpl'] = 'tree';
«ENDIF-»
        $url = ModUtil::url('«app.appName()»', '«controller.name()»', 'view', $viewArgs);
«ELSEIF controller.hasActions('main')-»
        // redirect to the main page
        $url = ModUtil::url('«app.appName()»', '«controller.name()»', 'main');
«ELSE-»
        $url = System::getHomepageUrl();
«ENDIF-»

«IF controller.hasActions('display')-»
«IF nestedSet-»
    /*
«ENDIF-»
        if ($args['commandName'] != 'delete') {
            // redirect to the detail page of treated «name.formatForCode()»
            $url = ModUtil::url('«app.appName()»', '«controller.name()»', 'display',
                                                             array('ot' => $this->objectType,
                                                                   '«idField()»' => $this->«idField()»));
        }
«IF nestedSet-»
    */
«ENDIF-»
«ENDIF-»
        return $url;
    }
«ENDDEFINE»

«DEFINE getRedirectUrl(Application app, Controller controller, String actionName) FOR Entity-»
«LET app.appName() AS appName-»
    /**
     * Get url to redirect to.
     */
    protected function getRedirectUrl($args, $obj, $repeatCreateAction = false)
    {
        if ($this->inlineUsage == true) {
            // inline usage, return to special function for closing the Zikula.UI.Window instance
            return ModUtil::url('«appName»', '«controller.name()»', 'handleInlineRedirect',
                                                                 array('idp' => $this->idPrefix,
                                                                       'id' => $this->«idField()»,
                                                                       'com' => $args['commandName']));
        }

        if ($repeatCreateAction) {
            return $this->repeatReturnUrl;
        }

        // normal usage, compute return url from given redirect code
        if (!in_array($this->returnTo, $this->getRedirectCodes())) {
            // invalid return code, so return the default url
            return $this->getDefaultReturnUrl($args, $obj);
        }

        // parse given redirect code and return corresponding url
        switch ($this->returnTo) {
«FOREACH app.controllers.controllers.reject(e|e.metaType == AjaxController) AS someController-»
«LET someController.name() AS controllerName-»
«IF someController.hasActions('main')-»
            case '«controllerName»':
                                    return ModUtil::url('«appName»', '«controllerName»');
«ENDIF-»
«IF someController.hasActions('view')-»
            case '«controllerName»View':
                                    return ModUtil::url('«appName»', '«controllerName»', 'view',
                                                             array('ot' => $this->objectType));
«ENDIF-»
«IF someController.hasActions('display')-»
            case '«controllerName»Display':
                                    if ($args['commandName'] != 'delete') {
                                        return ModUtil::url('«appName»', '«controllerName»', 'display',
                                                             array('ot' => $this->objectType,
                                                                   '«idField()»' => $this->«idField()»));
                                    }
                                    return $this->getDefaultReturnUrl($args, $obj);
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
«FOREACH incoming.select(e|e.metaType == OneToOneRelationship || e.metaType == OneToManyRelationship) AS incomingRelation-»
«LET incomingRelation.source AS sourceEntity-»
«IF sourceEntity.name != this.name-»
«FOREACH app.controllers.controllers.reject(e|e.metaType == AjaxController) AS someController-»
«LET someController.name() AS controllerName-»
«IF someController.hasActions('view')-»
            case '«controllerName»View«sourceEntity.name.formatForCodeCapital()»':
                                    return ModUtil::url('«appName»', '«controllerName»', 'view',
                                                             array('ot' => '«sourceEntity.name.formatForCode()»'));
«ENDIF-»
«IF someController.hasActions('display')-»
            case '«controllerName»Display«sourceEntity.name.formatForCodeCapital()»':
                                    if (isset($obj['«sourceEntity.idField()»']) && $obj['«sourceEntity.idField()»']) {
                                        return ModUtil::url('«appName»', '«controllerName»', 'display',
                                                             array('ot' => '«sourceEntity.name.formatForCode()»',
                                                                   '«sourceEntity.idField()»' => $obj['«sourceEntity.idField()»']));
                                    }
                                    return $this->getDefaultReturnUrl($args, $obj);
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
            default:
                                    return $this->getDefaultReturnUrl($args, $obj);
        }
    }
«ENDLET-»
«ENDDEFINE»

«DEFINE handleCommand(Application app, Controller controller, String actionName) FOR Entity-»
    /**
     * Command event handler.
     *
     * This event handler is called when a command is issued by the user. Commands are typically something
     * that originates from a {@link Zikula_Form_Plugin_Button} plugin. The passed args contains different properties
     * depending on the command source, but you should at least find a <var>$args['commandName']</var>
     * value indicating the name of the command. The command name is normally specified by the plugin
     * that initiated the command.
     * @see Zikula_Form_Plugin_Button
     * @see Zikula_Form_Plugin_ImageButton
     */
    public function handleCommand(Zikula_Form_View $view, &$args)
    {
        if ($args['commandName'] == 'delete') {
            if (!SecurityUtil::checkPermission('«app.appName()»:«name.formatForCodeCapital()»:', '::', ACCESS_DELETE)) {
                return $this->view->registerError(LogUtil::registerPermissionError());
            }
        }

        if (!in_array($args['commandName'], array('delete', 'cancel'))) {
            // do forms validation including checking all validators on the page to validate their input
            if (!$this->view->isValid()) {
                return false;
            }
        }

        $this->objectType = '«name.formatForCode()»';

«EXPAND ReassignRelatedObjects(true) FOREACH incoming.typeSelect(JoinRelationship)-»
«EXPAND ReassignRelatedObjects(false) FOREACH outgoing.typeSelect(JoinRelationship)-»

        $entityClass = '«appName()»_Entity_' . ucfirst($this->objectType);
        $repository = $this->entityManager->getRepository($entityClass);

        $«name.formatForCode()» = new $entityClass();
        if ($args['commandName'] != 'create') {
            $«name.formatForCode()» = $repository->selectById($this->«idField()», false);
        }

«EXPAND FetchInputData(name.formatForCode())-»

        if (in_array($args['commandName'], array('create', 'update'))) {
            // event handling if user clicks on create or update

            // Let any hooks perform additional validation actions
            $hook = new Zikula_ValidationHook('«app.name.formatForDB()».ui_hooks.«nameMultiple.formatForDB()».validate_edit', new Zikula_Hook_ValidationProviders());
            $validators = $this->notifyHooks($hook)->getValidators();
            // TODO validation incomplete

«IF hasTranslatableFields()-»
            // add translated values
            //$«name.formatForCode()»->setLocale(ZLanguage::getLanguageCode());
            foreach ($translations as $translation) {
                $translationLocale = $translation['locale'];
                foreach ($translation['fields'] as $fieldName => $value) {
                    $repository->translate($«name.formatForCode()», $fieldName, $locale, $value);
                }
            }

«ENDIF-»
            // save «name.formatForDisplay()»
            $successMessage = '';
            if ($args['commandName'] == 'create') {
                $this->entityManager->persist($«name.formatForCode()»);
                $this->entityManager->flush();

                // store new id
                $this->«idField()» = $«name.formatForCode()»->get«idField().toFirstUpper()»();
                // check if the insert has worked, might become obsolete due to exception usage
                if ($this->«idField()» === false) {
                    return LogUtil::registerError($this->__('Error! Creation attempt failed.'));
                }
                $successMessage = $this->__('Done! «name.formatForDisplayCapital()» created.');
            } else if ($args['commandName'] == 'update') {
                $this->entityManager->persist($«name.formatForCode()»);
«REM»                $updateResult = true/false;
                // check if the update has worked, might become obsolete due to exception usage
                if ($updateResult === false) {
                    return LogUtil::registerError($this->__('Error! Update attempt failed.'));
                }«ENDREM»
                $successMessage = $this->__('Done! «name.formatForDisplayCapital()» updated.');
            }

            $this->updateRelationLinks($«name.formatForCode()»);
            $this->entityManager->flush();

            LogUtil::registerStatus($successMessage);

            // Let any hooks know that we have created or updated an item
            $url = new Zikula_ModUrl('«app.appName()»', '«controller.name()»', 'display', ZLanguage::getLanguageCode(), array('ot' => $this->objectType, '«idField()»' => $this->«idField()»));
            $hook = new Zikula_ProcessHook('«app.name.formatForDB()».ui_hooks.«nameMultiple.formatForDB()».process_edit', $this->«idField()», $url);
            $this->notifyHooks($hook);
        } else if ($args['commandName'] == 'delete') {
            // event handling if user clicks on delete

            // Let any hooks perform additional validation actions
            $hook = new Zikula_ValidationHook('«app.name.formatForDB()».ui_hooks.«nameMultiple.formatForDB()».validate_delete', new Zikula_Hook_ValidationProviders());
            $validators = $this->notifyHooks($hook)->getValidators();
            // TODO validation incomplete

            // delete «name.formatForDisplay()»
            $this->entityManager->remove($«name.formatForCode()»);
            $this->entityManager->flush();
«REM»            if ($«name.formatForCode()»->delete() === false) {
                return LogUtil::registerError($this->__('Error! Deletion attempt failed.'));
            }«ENDREM»

            LogUtil::registerStatus($this->__('Done! «name.formatForDisplayCapital()» deleted.'));

            // Let any hooks know that we have deleted an item
            $hook = new Zikula_ProcessHook('«app.name.formatForDB()».ui_hooks.«nameMultiple.formatForDB()».process_delete', $this->«idField()»);
            $this->notifyHooks($hook);
        } else if ($args['commandName'] == 'cancel') {
            // event handling if user clicks on cancel
        }

        if ($args['commandName'] != 'cancel') {
            // clear view cache to reflect our changes
            $this->view->clear_cache();
        }

        if ($this->mode == 'edit') {
            ModUtil::apiFunc('PageLock', 'user', 'releaseLock',
                             array('lockName' => '«app.appName()»«name.formatForCodeCapital()»' . $this->«idField()»));
        }

        return $this->view->redirect($this->getRedirectUrl($args, $«name.formatForCode()», $repeatCreateAction));

        // We should in principle not end here at all, since the above command handlers should
        // match all possible commands, but we return "ok" (true) for all cases.
        // You could also return $this->view->setErrorMsg('Unexpected command')
        return true;
    }
«ENDDEFINE»


«DEFINE ReassignRelatedObjects(Boolean incoming) FOR JoinRelationship-»
«LET getRelationAliasName(!incoming).formatForCodeCapital() AS relationAliasName-»
«LET (!(incoming && this.metaType != ManyToManyRelationship || this.metaType == OneToOneRelationship)) AS many-»
«LET getUniqueRelationNameForJs(container.application, ((!incoming) ? target : source), false, incoming, relationAliasName) AS uniqueNameForJs-»
        // reassign the «((incoming) ? target : source).getEntityNameSingularPlural(many).formatForDisplay()» eventually chosen by the user
        $this->view->assign('user«relationAliasName.toFirstUpper()»', $this->retrieveRelatedObjects('«((incoming) ? source : target).name.formatForCode()»', '«uniqueNameForJs»ItemList', «IF !many»false«ELSE»true«ENDIF», 'POST'));
«ENDLET-»
«ENDLET-»
«ENDLET-»
«ENDDEFINE»


«DEFINE UpdateRelationLinks(Boolean incoming) FOR JoinRelationship-»
«LET getRelationAliasName(!incoming).formatForCodeCapital() AS relationAliasName-»
«LET (!(incoming && this.metaType != ManyToManyRelationship || this.metaType == OneToOneRelationship)) AS many-»
«LET getUniqueRelationNameForJs(container.application, ((!incoming) ? target : source), false, incoming, relationAliasName) AS uniqueNameForJs-»
«IF many && this.getEditStageCode(incoming) > 1-»
«LET ((incoming) ? source : target).name.formatForCode() AS objectType-»
«IF incoming-»«REM»only incoming for now, see http://code.zikula.org/generator/ticket/89«ENDREM»«""-»
        $relatedIds = $this->request->getPost()->get('«uniqueNameForJs»ItemList', '');
        if ($this->mode != 'create') {
            // remove all existing references
            $entity->get«relationAliasName.toFirstUpper()»()->clear();
        }
        if (!empty($relatedIds)) {
            $relatedIds = explode(',', $relatedIds);
        }
        if (is_array($relatedIds) && count($relatedIds)) {
            $entityClass = '«appName()»_Entity_' . ucfirst($this->objectType);
            $repository = $this->entityManager->getRepository($entityClass);
            // create new links
            foreach ($relatedIds as $relatedId) {
«IF this.metaType != ManyToManyRelationship-»
«REM»TODO select before loop with one WHERE IN«ENDREM»
                $linkObj = $repository->selectById($relatedId);
                if ($entity->get«relationAliasName.toFirstUpper()»()->contains($linkObj)) {
                    continue;
                }
                $entity->get«relationAliasName.toFirstUpper()»()->add($linkObj);
«IF bidirectional-»
«REM»TODO inverse handling missing, will be done with special entity methods«ENDREM»
«ENDIF-»
«ELSE-»
                $linkObj = new «((ManyToManyRelationship)this).implClassModelRefRecord()»();
                $linkObj->«source.idField()» = «IF incoming»$relatedId«ELSE»$this->«((incoming) ? target : source).idField()»«ENDIF»;
                $linkObj->«target.idField()» = «IF !incoming»$relatedId«ELSE»$this->«((incoming) ? target : source).idField()»«ENDIF»;
                $this->entityManager->persist($linkObj);
«ENDIF-»
            }
        }
«ENDIF-»
«ENDLET-»
«ENDIF-»
«ENDLET-»
«ENDLET-»
«ENDLET-»
«ENDDEFINE»


«DEFINE FetchInputData(String obj) FOR Entity-»
        // fetch posted data input values as an associative array
        $formData = $this->view->getValues();
        // we want the array with our field values
        $formData = $formData['«name.formatForDB()»'];

«EXPAND FetchRelationValue(true) FOREACH incoming.typeSelect(JoinRelationship).reject(e|e.metaType == ManyToManyRelationship)-»
«LET getUniqueDerivedFields().reject(e|e.primaryKey) AS uniqueFields-»
«LET getUserFields() AS userFields-»
«LET getUploadFields() AS uploadFields-»
«IF !(uniqueFields.isEmpty && userFields.isEmpty && uploadFields.isEmpty)-»

        if (in_array($args['commandName'], array('create', 'update'))) {
«FOREACH uniqueFields AS uniqueField-»
«REM»TODO: move this into model validator#validateAll()«ENDREM»
            // check if another «name.formatForDisplay()» with the same «uniqueField.name.formatForDisplay()» does already exist
            if ($object->get_validator()->checkIf«uniqueField.name.formatForCodeCapital()»Exists($formData['«uniqueField.name.formatForCode()»'], $this->«idField()»)) {
                return LogUtil::registerError($this->__f('The «uniqueField.name.formatForDisplay()» %s is already assigned. Please choose another «uniqueField.name.formatForDisplay()».', array($formData['«uniqueField.name.formatForCode()»'])));
            }
«ENDFOREACH-»
«FOREACH userFields AS userField-»
«LET userField.name.formatForCode() AS realName-»
            $formData['«realName»'] = (int) $this->request->getPost()->filter('«realName»', 0, FILTER_VALIDATE_INT);
            if (!$formData['«realName»'] || UserUtil::getVars($formData['«realName»']) === false) {
«IF userField.mandatory-»
                // Oops, we have an invalid user id. As this field is mandatory, we raise an error.
                return LogUtil::registerError($this->__('Invalid value received for field "«userField.name.formatForDisplay()»".'));
«ELSE-»
                // Oops, we have an invalid user id. As this field is not mandatory, we simply set it to 0.
                $formData['«realName»'] = 0;
«ENDIF-»
            }
«ENDLET-»
«ENDFOREACH-»
«IF sluggable && slugUpdatable-»
«IF slugUnique-»
            // check if another «name.formatForDisplay()» with the same slug does already exist
            if ($object->get_validator()->checkIfSlugExists($formData['slug'], $this->«idField()»)) {
                return LogUtil::registerError($this->__f('The slug %s is already assigned. Please choose another slug.', array($formData['slug'])));
            }
«ENDIF-»
            $formData['slug'] = «container.application.appName()»_Util_Controller::formatPermalink($formData['slug']);
«ENDIF-»
«IF !uploadFields.isEmpty-»
            $formData = $this->handleUploads($formData, $«name.formatForCode()»);
            if ($formData == false) {
                return false;
            }
«ENDIF-»
        }
«ENDIF-»
«ENDLET-»
«ENDLET-»
«ENDLET-»

        $repeatCreateAction = false;
        if ($args['commandName'] == 'create' && isset($formData['repeatcreation'])) {
            $repeatCreateAction = $formData['repeatcreation'];
            unset($formData['repeatcreation']);
        }
«IF hasTranslatableFields()-»

        // process translated fields
        list($formData, $translations) = AdShare_Util_Translatable::processEntityAfterEdit($this->objectType, $«obj», $formData);
«ENDIF-»

        // assign fetched data
        $«obj»->merge($formData);
«ENDDEFINE»

«REM»Assign input value from incoming 1:1 and 1:n relationships (example: get customerid for an order).
As the autocomplete fields are not done with a Form plugin (yet), we do that manually.«ENDREM»
«DEFINE FetchRelationValue(Boolean incoming) FOR JoinRelationship-»
«LET getRelationAliasName(!incoming).formatForCodeCapital() AS relationAliasName-»
«LET getUniqueRelationNameForJs(container.application, ((!incoming) ? target : source), false, incoming, relationAliasName) AS uniqueNameForJs-»
        $formData['«source.idField()»'] = (int) $this->request->getPost()->filter('«uniqueNameForJs»ItemList', 0, FILTER_VALIDATE_INT);
«REM»Alternative: $address->link('Customer', array($customer['id']));«ENDREM»«""-»
        if (!$formData['«source.idField()»']) {
            // Oops, we have an invalid relation id. As this field is mandatory, we raise an error.
            return LogUtil::registerError($this->__('Invalid value received for relation field "«relationAliasName.formatForDisplay()»".'));
        }
«ENDLET-»
«ENDLET-»
«ENDDEFINE»


«DEFINE handleUploads(Application app) FOR Entity-»
    /**
     * Helper method to process upload fields
     */
    protected function handleUploads($formData, $existingObject)
    {
«LET getUploadFields() AS uploadFields-»
«IF !uploadFields.isEmpty-»
        // initialise the upload handler
        $uploadManager = new «app.appName()»_UploadHandler();

        // list of upload fields to consider
        $uploadFields = array(«FOREACH uploadFields AS uploadField SEPARATOR ", "»'«uploadField.name.formatForCode()»'«ENDFOREACH»);
        // list of mandatory fields
        $uploadFieldsMandatory = array(«FOREACH uploadFields.select(e|e.mandatory) AS uploadField SEPARATOR ", "»'«uploadField.name.formatForCode()»'«ENDFOREACH»);

        $existingObjectData = $existingObject->get«name.toFirstUpper()»();

        // process all fields
        foreach ($uploadFields as $uploadField) {
            // check if an existing file must be deleted
            $hasOldFile = (!empty($existingObjectData[$uploadField]));
            $hasBeenDeleted = !$hasOldFile;
            if ($this->mode != 'create') {
                if (isset($formData[$uploadField . 'DeleteFile'])) {
                    if ($hasOldFile && $formData[$uploadField . 'DeleteFile'] === true) {
                        // remove upload file (and image thumbnails)
                        $existingObjectData = $uploadManager->deleteUploadFile($this->objectType, $existingObjectData, $uploadField);
                        if (empty($existingObjectData[$uploadField])) {
                            $existingObject->set«name.toFirstUpper()»($existingObjectData);
                        }
                    }
                    unset($formData[$uploadField . 'DeleteFile']);
                    $hasBeenDeleted = true;
                }
            }

            // look whether a file has been provided
            if (!$formData[$uploadField] || $formData[$uploadField]['size'] == 0) {
                // no file has been uploaded
                unset($formData[$uploadField]);
                // skip to next one
                continue;
            }

            if ($hasOldFile && $hasBeenDeleted !== true && $this->mode != 'create') {
                // remove old upload file (and image thumbnails)
                $existingObjectData = $uploadManager->deleteUploadFile($this->objectType, $existingObjectData, $uploadField);
                if (empty($existingObjectData[$uploadField])) {
                    $existingObject->set«name.toFirstUpper()»($existingObjectData);
                }
            }

            // do the actual upload (includes validation, physical file processing and reading meta data)
            $uploadResult = $uploadManager->performFileUpload($this->objectType, $formData, $uploadField);
            // assign the upload file name
            $formData[$uploadField] = $uploadResult['fileName'];
            // assign the meta data
            $formData[$uploadField . 'Meta'] = $uploadResult['metaData'];

            // if current field is mandatory check if everything has been done 
            if (in_array($uploadField, $uploadFieldsMandatory) && $formData[$uploadField] === false) {
                // mandatory upload has not been completed successfully
                return false;
            }

            // upload succeeded
        }
«ENDIF-»
«ENDLET-»
        return $formData;
    }
«ENDDEFINE»

