«IMPORT modulestudio»
«IMPORT persistence»
«IMPORT processing»
«IMPORT templates::zclassic::smallstuff»
«EXTENSION extensions::Utils»
«EXTENSION extensions::UtilsBO»

«REM»start point for the Processor creation«ENDREM»
«DEFINE Root FOR Module»
	«EXPAND Root(this) FOREACH processingContainer.processors-»
	«FILE "common.php"»«EXPAND FileHelper::phpFileHeader(this)»«EXPAND CommonFunctions-»«ENDFILE»
«ENDDEFINE»

«DEFINE CommonFunctions FOR Module-»
/**
 * returns an array of all allowed object types in «modName()»
 */
function «modName()»_getObjectTypes()
{
    $allowedObjectTypes = array();
«FOREACH persistenceContainer.tables AS tab-»
    $allowedObjectTypes[] = '«moduleName(tab.name)»';
«ENDFOREACH-»
    return $allowedObjectTypes;
}

/**
 * utility function for managing render templates
 */
function «modName()»_processRenderTemplate(&$render, $type, $objectType, $func, $args=array())
{
    $template = DataUtil::formatForOS('«modName()»_' . $type . '_' . $objectType . '_' . $func);
    $tpl = FormUtil::getPassedValue('tpl', isset($args['tpl']) ? $args['tpl'] : '');
    if (!empty($tpl) && $render->template_exists($template . '_' . DataUtil::formatForOS($tpl) . '.htm')) {
        $template .= '_' . DataUtil::formatForOS($tpl);
    }
    $template .= '.htm';

    $raw = FormUtil::getPassedValue('raw', (isset($args['raw']) && is_bool($args['raw'])) ? $args['raw'] : false);
    if ($raw == true) {
        // standalone output
        $render->display($template);
        return true;
    }

    // normal output
    return $render->fetch($template);
}
«ENDDEFINE»

«REM»creates a file for every Processor instance«ENDREM»
«DEFINE Root(Module module) FOR Processor-»
	«FILE "lib/" + module.modName().toFirstUpper() + "/" + dbName(name).toFirstUpper() + ".php"»«EXPAND FileHelper::phpFileHeader(module)»«EXPAND ProcessorImpl(module)»«ENDFILE»
    «FILE "lib/" + module.modName().toFirstUpper() + "/Api/" + dbName(name).toFirstUpper() + ".php"»«EXPAND FileHelper::phpFileHeader(module)»«EXPAND ProcessorApiImpl(module)»«ENDFILE»
«ENDDEFINE»

«REM»file structure implementation«ENDREM»
«DEFINE ProcessorImpl(Module module) FOR Processor-»

/**
 * This is the «name» controller class providing navigation and interaction functionality
 *
 * @author       «module.author»
 */
class «module.modName().toFirstUpper()»_«dbName(name).toFirstUpper()» extends Zikula_Controller
{
    /**
     * Even though we're handling objects for multiple tables, we only have one method for any use case.
     * The specific functionality for each object is encapsulated in the actual class implementation within the
     * module's classes directory while the handling code can remain identical for any number of entities.
     * This component-based approach allows you to have generic handler code which relies on the functionality
     * implemented in the object's class in order to achieve it's goals.
     */

«EXPAND Root(module) FOREACH processorStates-»
«IF module.needsConfig() && ProcessorType == 'ADMIN'-»

    /*
     * This function takes care of the module configuration.
     *
     * @author       «module.author»
     * @return       Render output
     */
    public function config()
    {
        // Create new Form reference
        $render = FormUtil::newForm('«module.modName()»');

        // Execute form using supplied template and page event handler
        return $render->Execute('«module.modName()»_admin_config.htm', new «module.modName().toFirstUpper()»_Admin_Config());
    }

«ENDIF-»
}
«ENDDEFINE»



«DEFINE Root(Module module) FOR ProcessorState-»

    /**
«EXPAND StateDoc(module)-»
     */
    public function «dbName(name)»($args)
    {
«EXPAND StateImpl(module)-»
    }
«ENDDEFINE»

«DEFINE StateDoc(Module module) FOR ProcessorState-»
«IF type == ProcessorStateType::MAIN-»
     * This method is the default function, and is called whenever the
     * module's «moduleName(stateProcessor.name)» area is called without defining arguments.
«ELSEIF type == ProcessorStateType::VIEW-»
     * This method provides a generic item list overview.
«ELSEIF type == ProcessorStateType::DISPLAY-»
     * This method provides a generic item detail view.
«ELSEIF type == ProcessorStateType::EDIT-»
     * This method provides a generic handling of all edit requests.
«ELSEIF type == ProcessorStateType::CUSTOM-»
     * This is a custom method. Documentation for this will be improved in later versions.
«ENDIF-»
     *
     * @author       «module.author»
     * @params       TODO
«IF type == ProcessorStateType::VIEW || type == ProcessorStateType::DISPLAY || type == ProcessorStateType::EDIT || type == ProcessorStateType::DELETE-»
     * @param        ot             string    treated object type
«IF type == ProcessorStateType::DELETE-»
     * @param        id		        int	      ID of the entry
     * @param        confirmation   boolean   Confirm the deletion, else a confirmation page is displayed
«ENDIF-»
«IF type == ProcessorStateType::VIEW-»
     * @param        sort           string    sorting field
     * @param        sdir           string    sorting direction
     * @param        pos            int       current pager position
«ENDIF-»
     * @param        tpl            string    name of alternative template (for alternative display options, feeds and xml output)
     * @param        raw            boolean   optional way to display a template instead of fetching it (needed for standalone output)
«ENDIF-»
     * @return       Render output
«ENDDEFINE»

«DEFINE StateImpl(Module module) FOR ProcessorState-»
«EXPAND PermissionCheck-»
«LET module.modName() AS modName-»
«IF type != ProcessorStateType::MAIN-»
        // parameter specifying which type of objects we are treating
        $objectType = FormUtil::getPassedValue('ot', '«module.getLeadObj()»', 'GET');

        if (!in_array($objectType, «modName»_getObjectTypes())) {
            $objectType = '«module.getLeadObj()»';
        }
«ENDIF-»
«IF type == ProcessorStateType::MAIN-»«EXPAND PStates::Main::Impl(modName)-»
«ELSEIF type == ProcessorStateType::VIEW-»«EXPAND PStates::View::Impl(modName)-»
«ELSEIF type == ProcessorStateType::DISPLAY-»«EXPAND PStates::Display::Impl(modName)-»
«ELSEIF type == ProcessorStateType::EDIT-»«EXPAND PStates::Edit::Impl(modName)-»
«ELSEIF type == ProcessorStateType::DELETE-»«EXPAND PStates::Delete::Impl(modName)-»
«ELSEIF type == ProcessorStateType::CUSTOM-»«EXPAND PStates::Custom::Impl(modName)-»
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«DEFINE PermissionCheck FOR ProcessorState-»
«REM»will be filled by Advices«ENDREM»
«ENDDEFINE»



«DEFINE ProcessorApiImpl(Module module) FOR Processor-»
/**
 * This is the «name» api helper class.
 *
 * @author       «module.author»
 */
class «module.modName().toFirstUpper()»_API_«dbName(name).toFirstUpper()» extends Zikula_Api
{
    /**
     * get available «name» panel links
     *
     * @author       «module.author»
     * @return       array      array of admin links
     */
    public function getlinks()
    {
        $links = array();

«FOREACH module.persistenceContainer.tables AS tab-»
        if (SecurityUtil::checkPermission('«module.modName()»::', '::', ACCESS_READ)) {
            $links[] = array('url' => ModUtil::url('«module.modName()»', 'admin', 'view', array('ot' => '«moduleName(tab.name)»')),
                             'text' => $this->__('«formattedNameCapitalized(tab.nameMultiple)»'));
        }
«ENDFOREACH-»
«IF type == ProcessorType::ADMIN && module.needsConfig()-»
        if (SecurityUtil::checkPermission('«module.modName()»::', '::', ACCESS_ADMIN)) {
            $links[] = array('url' => ModUtil::url('«module.modName()»', 'admin', 'config'), 'text' => $this->__('Configuration'));
        }
«ENDIF-»
        return $links;
    }
}
«ENDDEFINE»

