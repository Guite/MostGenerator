«IMPORT modulestudio»
«IMPORT templates::zclassic::smallstuff»
«EXTENSION extensions::Utils»

«REM»start point for the Util class creation«ENDREM»
«DEFINE Root FOR Application»
    «FILE "lib/".msconcat(appName()).msconcat("/Base/Util.php")»«EXPAND FileHelper::phpFileHeader(this)»«EXPAND CommonFunctionsBase-»«ENDFILE»
    «FILE "lib/".msconcat(appName()).msconcat("/Util.php")»«EXPAND FileHelper::phpFileHeader(this)»«EXPAND CommonFunctionsImpl-»«ENDFILE»
«ENDDEFINE»

«DEFINE CommonFunctionsBase FOR Application-»
/**
 * Utility helper base class
 */
class «appName()»_Base_Util
{
    /**
     * Returns an array of all allowed object types in «appName()».
     *
     * @param        context        string        usage context (allowed values: controllerAction, api, actionHandler, block, contentType, mailz)
     * @param        args           array         additional arguments
     * @return array list of allowed object types
     */
    public static function getObjectTypes($context = '', $args = array())
    {
        if (!in_array($context, array('controllerAction', 'api', 'actionHandler', 'block', 'contentType', 'mailz'))) {
            $context = 'controllerAction';
        }

        $allowedObjectTypes = array();
«FOREACH models.entities AS entity-»
        $allowedObjectTypes[] = '«entity.name.formatForCode()»';
«ENDFOREACH-»
        return $allowedObjectTypes;
    }

    /**
     * Utility method for managing view templates.
     *
     * @param        view           Zikula_View   reference to view object
     * @param        type           string        current type (admin, user, ...)
     * @param        objectType     string        name of treated entity type
     * @param        func           string        current function (main, view, ...)
     * @param        args           array         additional arguments
     * @return mixed Output.
     */
    public static function processViewTemplate($view, $type, $objectType, $func, $args = array())
    {
        // create the base template name
        $template = DataUtil::formatForOS($type . '/' . $objectType . '/' . $func);

        // check for template extension
        $templateExtension = self::determineTemplateExtension($view, $type, $objectType, $func, $args);

        // check whether a special template is used
        $tpl = FormUtil::getPassedValue('tpl', isset($args['tpl']) ? $args['tpl'] : '');
        if (!empty($tpl) && $view->template_exists($template . '_' . DataUtil::formatForOS($tpl) . '.' . $templateExtension)) {
            $template .= '_' . DataUtil::formatForOS($tpl);
        }
        $template .= '.' . $templateExtension;

        // look whether we need output with or without the theme
        $raw = FormUtil::getPassedValue('raw', (isset($args['raw']) && is_bool($args['raw'])) ? $args['raw'] : false);
        if (!$raw && in_array($templateExtension, array('csv', 'rss', 'atom', 'xml', 'pdf', 'vcard', 'ical'))) {
            $raw = true;
        }

        if ($raw == true) {
            // standalone output
            if ($templateExtension == 'pdf') {
                return self::processPdf();
            }
            else {
                $view->display($template);
            }
            return true;
        }

        // normal output
        return $view->fetch($template);
    }

    /**
     * Get extension of currently treated template
     *
     * @param        view           Zikula_View   reference to view object
     * @param        type           string        current type (admin, user, ...)
     * @param        objectType     string        name of treated entity type
     * @param        func           string        current function (main, view, ...)
     * @param        args           array         additional arguments
     * @return array list of allowed template extensions.
     */
    protected static function determineTemplateExtension($view, $type, $objectType, $func, $args = array())
    {
        $templateExtension = 'tpl';
        if (!in_array($func, array('view', 'display'))) {
            return $templateExtension;
        }

        $extParams = self::availableTemplateExtensions($type, $objectType, $func, $args);
        foreach ($extParams as $extension) {
            $extensionCheck = (int) FormUtil::getPassedValue('use' . $extension . 'ext', 0, 'GET');
            if ($extensionCheck == 1) {
                $templateExtension = $extension;
                break;
            }
        }
        return $templateExtension;
    }

    /**
     * Get list of available template extensions
     *
     * @param        type           string        current type (admin, user, ...)
     * @param        objectType     string        name of treated entity type
     * @param        func           string        current function (main, view, ...)
     * @param        args           array         additional arguments
     * @return array list of allowed template extensions.
     */
    public static function availableTemplateExtensions($type, $objectType, $func, $args = array())
    {
        $extParams = array();
        if ($func == 'view') {
            if (SecurityUtil::checkPermission('«appName()»::', '::', ACCESS_ADMIN)) {
                $extParams = array('csv', 'rss', 'atom', 'xml'/*, 'pdf'*/);
            }
            else {
                $extParams = array('rss', 'atom'/*, 'pdf'*/);
            }
        }
        elseif ($func == 'display') {
            $extParams = array('xml'/*, 'pdf'*/);
        }
        return $extParams;
    }

    /**
     * Processes a template file using dompdf (LGPL).
     * To use this functionality:
     *    - download dompdf from the project page at http://www.digitaljunkies.ca/dompdf/
     *    - copy it to modules/«appName()»/lib/vendor/dompdf/ (see inclusion below)
     *    - override the corresponding template
     *
     * @param        template       string        name of template to use
     * @return mixed Output.
     */
    protected static function processPdf($template)
    {
        // include dom pdf classes
        $pdfConfigFile = 'modules/«appName()»/lib/vendor/dompdf/dompdf_config.inc.php';
        if (!file_exists($pdfConfigFile)) {
            return false;
        }
        require_once($pdfConfigFile);

        // first the content, to set page vars
        $output = $render->fetch($template);

        // see http://codeigniter.com/forums/viewthread/69388/P15/#561214
        $output = utf8_decode($output);

        // then the surrounding
        $output = $render->fetch('include_pdfheader.tpl') . $output . '</body></html>';

        // create name of the pdf output file
        $fileTitle = self::formatPermalink(System::getVar('sitename')) . '-' . self::formatPermalink(PageUtil::getVar('title'));
        $fileTitle .= '-' . date('Ymd') . '.pdf';

//if ($_GET['dbg'] == 1) die($output);

        // instantiate pdf object
        $pdf = new DOMPDF();
        // define page properties
        $pdf->set_paper('A4');
        // load html input data
        $pdf->load_html($output);
        // create the actual pdf file
        $pdf->render();
        // stream output to browser
        $pdf->stream($fileTitle);

        // prevent additional output by shutting down the system
        System::shutDown();
        return true;
    }

    /**
     * Create nice permalinks
     */
    public static function formatPermalink($name)
    {
        $name = str_replace(array('ä', 'ö', 'ü', 'Ä', 'Ö', 'Ü', 'ß', '.', '?', '"', '/', 'é', 'è', 'â'),
                            array('ae', 'oe', 'ue', 'Ae', 'Oe', 'Ue', 'ss', '', '', '', '-', 'e', 'e', 'a'),
                            $name);
        $name = DataUtil::formatPermalink($name);
        return strtolower($name);
    }
«IF hasUploads()-»

    /**
     * The «appName().formatForDB()»ImageThumb modifier displays a thumbnail image
     *
     * @param  string    $fileName   The input file name.
     * @param  string    $filePath   The input file path (including file name).
     * @param  int       $width      Desired width.
     * @param  int       $height     Desired height.
     * @param  array     $thumbArgs  Additional arguments.
     * @return string The thumbnail file path.
     */
    public static function getImageThumb($fileName = '', $filePath = '', $width = 100, $height = 80, $thumbArgs = array())
    {
        if (empty($fileName) || empty($filePath) || !file_exists($filePath)) {
            return;
        }
        if (!is_array($thumbArgs)) {
            $thumbArgs = array();
        }

        $mediaModule = 'Thumbnail';
        if (!ModUtil::available($mediaModule)) {
            return $filePath;
        }

        $thumbArgs['filename'] = $filePath;
        $thumbArgs['far'] = 1; // force aspect ratio
        $thumbArgs['w'] = $width;
        $thumbArgs['h'] = $height;

        // compute thumbnail file name
        $thumbFileName = ModUtil::apiFunc($mediaModule, 'user', 'generateThumbnailName', $thumbArgs);

        // move thumbnail into sub folder
        $thumbFileName = str_replace($filePath, $filePath . 'tmb/', $thumbFileName);

        // return file if already existing
        if (file_exists($thumbFileName)) {
            return $thumbFileName;
        }

        // create the thumbnail
        $thumbArgs['tmbname'] = $thumbFileName;
        ModUtil::apiFunc($mediaModule, 'user', 'generateThumbnailDirect', $thumbArgs);

        return $thumbFileName;
    }

    /**
     * Retrieve the base path for given object type and upload field combination.
     *
     * @param        objectType     string        name of treated entity type
     * @param        fieldName      string        name of upload field
     * @param        args           array         additional arguments
     * @return mixed Output.
     */
    public static function getFileBaseFolder($objectType, $fieldName)
    {
        if (!in_array($objectType, self::getObjectTypes())) {
            $objectType = '«getLeadingEntity().name.formatForCode()»';
        }

        $basePath = 'modules/«appName()»/files/';

        switch ($objectType) {
«FOREACH getUploadEntities() AS entity-»
«LET entity.getUploadFields() AS uploadFields-»
            case '«entity.name.formatForCode()»':
«IF uploadFields.size > 1-»
                            $basePath .= '«entity.nameMultiple.formatForDB()»/';
                            switch ($fieldName) {
«FOREACH uploadFields AS uploadField-»
                                case '«uploadField.name.formatForCode()»':
                                    $basePath .= '«uploadField.subFolderPathSegment()»/';
                                    break;
«ENDFOREACH-»
                            }
«ELSE-»
                            $basePath .= '«entity.nameMultiple.formatForDB()»/«uploadFields.get(0).subFolderPathSegment()»/';
«ENDIF-»
                            break;
«ENDLET-»
«ENDFOREACH-»
        }

        return $basePath;
    }

    /**
     * Display a given file size in a readable format
     *
     * @param        size           string        file size in bytes
     * @param        nodesc         boolean       if set to true the description will not be appended
     * @param        onlydesc       boolean       if set to true only the description will be returned
     * @return string file size in a readable form
     */
    public static function getReadableFileSize($size, $nodesc = false, $onlydesc = false)
    {
        $dom = ZLanguage::getModuleDomain('«appName()»');
        $sizeDesc = __('Bytes', $dom);
        if ($size >= 1024) {
            $size /= 1024;
            $sizeDesc = __('KB', $dom);
        }
        if ($size >= 1024) {
            $size /= 1024;
            $sizeDesc = __('MB', $dom);
        }
        if ($size >= 1024) {
            $size /= 1024;
            $sizeDesc = __('GB', $dom);
        }
        $sizeDesc = '&nbsp;' . $sizeDesc;

        // format number
        $dec_point = ',';
        $thousands_separator = '.';
        if ($size - number_format($size, 0) >= 0.005) {
            $size = number_format($size, 2, $dec_point, $thousands_separator);
        } else {
            $size = number_format($size, 0, '', $thousands_separator);
        }

        // append size descriptor if desired
        if (!$nodesc) {
            $size .= $sizeDesc;
        }

        // return either only the description or the complete string
        $result = ($onlydesc) ? $sizeDesc : $size;
        return $result;
    }
«ENDIF-»
}
«ENDDEFINE»

«DEFINE CommonFunctionsImpl FOR Application-»
/**
 * Utility helper implementation class
 */
class «appName()»_Util extends «appName()»_Base_Util
{
    // feel free to add your own convenience methods here
}
«ENDDEFINE»
