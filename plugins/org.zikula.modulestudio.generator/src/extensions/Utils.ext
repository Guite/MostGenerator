
import modulestudio;
extension org::eclipse::xtend::util::stdlib::io;


/* app related functions */
cached String msVersion() :
    "0.5.1";
cached String msUrl() :
    "http://modulestudio.de";



/* not used yet, just for testing */
cached String constantName(Action this) :
	"ACTION_" + name.toUpperCase();
 
cached String constantName(ActionEvent this) :
	"EVENT_" + name.toUpperCase();

// ugly (and temporary) way to bypass that EfficientLazyString can not be compared
cached String msconcat(String a, String b) :
    a.replaceAll(a, a + b);

/*
 * naming extensions
 */
cached String appName(Application this) :
	name.formatForCode().toFirstUpper();

cached String formatForCode(String s)
	: JAVA extensions.Utils.formatForCode(java.lang.String);
cached String formatForCodeCapital(String s)
	: s.formatForCode().toFirstUpper();
cached String formatForDB(String s)
	: JAVA extensions.Utils.formatForDB(java.lang.String);
cached String formatForDisplay(String s)
	: JAVA extensions.Utils.formatForDisplay(java.lang.String);
cached String formatForDisplayCapital(String s)
	: JAVA extensions.Utils.formatForDisplayCapital(java.lang.String);

cached String displayBool(Boolean b)
    : ((b) ? 'true' : 'false');

cached boolean needsConfig(Application this) :
	(models.variables.vars.size > 0);

cached String configControllerType(Application this) :
    ((controllers.controllers.typeSelect(AdminController).size > 0) ? 'modulestudio::AdminController'
        : ((controllers.controllers.typeSelect(UserController).size > 0) ? 'modulestudio::UserController'
            : controllers.controllers.get(0).metaType.toString()
    ));
cached String configController(Application this) :
    configControllerType().replaceAll('modulestudio::', '').replaceAll('Controller', '');

// we have to go the ugly way here to bypass that EfficientLazyString can not be compared
cached String fullEntityName(Entity this)
    : container.application.prefix.formatForDB().msconcat("_").msconcat(name.formatForDB());



// return model container which are default data sources
cached getDefaultDataSource(Application this)
    : models.select(e | e.isDefaultDataSource == true).get(0);

// return all entities with leading = true
cached getLeadingEntity(Application this)
    : models.entities.select(e | e.leading == true).get(0);
// return all derived fields (excluding calculated fields)
cached getDerivedFields(Entity this)
    : fields.typeSelect(DerivedField);
cached getDerivedFieldsWithAlias(Entity this)
    : getDerivedFields().select(e | e.alias != null && e.alias != "");
// return all fields with leading = true
cached getLeadingField(Entity this)
    : getDerivedFields().select(e | e.leading == true).get(0);
// return all fields with primaryKey = true
cached getPrimaryKeyField(Entity this)
    : getDerivedFields(this).select(e | e.primaryKey == true).get(0);



cached String idField(Entity entity)
    : entity.getPrimaryKeyField().name.formatForDB();

cached String actualFieldName(EntityField this)
    : name;

cached String actualFieldName(DerivedField this)
    : ((alias != null && alias != "") ? alias : name);


cached boolean hasUploads(Application this)
    : (models.entities.fields.typeSelect(UploadField).size > 0);

cached getUploadEntities(Application this)
    : (models.entities.select(e|e.fields.typeSelect(UploadField).size > 0));

cached String subFolderPathSegment(UploadField this)
    : (subFolderName != null && subFolderName != "") ? subFolderName.formatForDB() : name.formatForDB();

cached String namingSchemeAsInt(UploadField this) :
    switch (namingScheme) {
       case UploadNamingScheme::ORIGINALWITHCOUNTER    : '0'
       case UploadNamingScheme::RANDOMCHECKSUM         : '1'
       case UploadNamingScheme::FIELDNAMEWITHCOUNTER   : '2'
       default: '0'
    };

// return all join relations (excluding inheritance)
cached getJoinRelations(Models this)
    : relations.typeSelect(JoinRelationship);

cached isInheriting(Entity this)
    : outgoing.typeSelect(InheritanceRelationship).size > 0;
cached InheritanceRelationship getInheritanceRelation(Entity this)
    : outgoing.typeSelect(InheritanceRelationship).get(0);
cached Entity parentType(Entity this)
    : getInheritanceRelation().target;

cached isInheriter(Entity this)
    : incoming.typeSelect(InheritanceRelationship).size > 0;
cached getChildRelations(Entity this)
    : incoming.typeSelect(InheritanceRelationship);
cached getChildRelationsWithAggregation(Entity this)
    : getChildRelations().select(e|e.strategy == InheritancyStrategyType::COLUMNAGGREGATION);

/* if we have id or fooid return fooid; otherwise return the actual field name of the referenced field */
cached relationFieldName(Entity refEntity, String refField)
    : (refField.toLowerCase() == 'id' || refField.toLowerCase() == refEntity.idField()) ? refEntity.idField() : refEntity.fields.select(e|e.name == refField).get(0).actualFieldName().formatForCode();

/* get local field for 1:1 and 1:n */ 
cached getRelationLocalField(JoinRelationship this, Boolean incoming)
    : (!incoming) ? source.relationFieldName(sourceField) : ((targetField != "id" && targetField != (target.name + "id")) ? target.relationFieldName(targetField) : source.relationFieldName(sourceField));
/* get foreign field for 1:1 and 1:n */ 
cached getRelationForeignField(JoinRelationship this, Boolean incoming)
    : (incoming) ? source.relationFieldName(sourceField) : ((targetField != "id" && targetField != (target.name + "id")) ? target.relationFieldName(targetField) : source.relationFieldName(sourceField));

cached String getTargetMultiplicity(JoinRelationship this)
    : 'Many';
cached String getTargetMultiplicity(OneToOneRelationship this)
    : 'One';

/* retrieve integer value defining which relation edit type will be implemented
 * this mapping is done to have a more appropriate logic inside the generator
 * possible values:
 *    0    Nothing is being done
 *    1    Select related object
 *    2    Create and edit related object
 *    3    Combination of 1 and 2
 */
cached Integer getEditStageCode(JoinRelationship this, Boolean incoming) :
    switch (editType) {
       case RelationEditType::ACTIVE_NONE_PASSIVE_CHOOSE    : ((incoming) ? 1 : 0)
       case RelationEditType::ACTIVE_NONE_PASSIVE_EDIT      : ((incoming) ? 3 : 0)
       case RelationEditType::ACTIVE_CHOOSE_PASSIVE_NONE    : ((incoming) ? 3 : 2)  // invalid --> default as fallback
       case RelationEditType::ACTIVE_EDIT_PASSIVE_CHOOSE    : ((incoming) ? 1 : 2)
       case RelationEditType::ACTIVE_EDIT_PASSIVE_EDIT      : ((incoming) ? 3 : 2)  // default
       case RelationEditType::ACTIVE_EDIT_PASSIVE_NONE      : ((incoming) ? 3 : 2)  // invalid --> default as fallback
       default: ((incoming) ? 3 : 2)
    };

/* specialisation for many-to-many relations */
cached Integer getEditStageCode(ManyToManyRelationship this, Boolean incoming) :
    switch (editType) {
       case RelationEditType::ACTIVE_NONE_PASSIVE_CHOOSE    : ((incoming) ? 1 : 0)
       case RelationEditType::ACTIVE_NONE_PASSIVE_EDIT      : ((incoming) ? 3 : 0)
       case RelationEditType::ACTIVE_CHOOSE_PASSIVE_NONE    : ((incoming) ? 0 : 1)
       case RelationEditType::ACTIVE_EDIT_PASSIVE_CHOOSE    : ((incoming) ? 1 : 3)
       case RelationEditType::ACTIVE_EDIT_PASSIVE_EDIT      : ((incoming) ? 3 : 3)  // default
       case RelationEditType::ACTIVE_EDIT_PASSIVE_NONE      : ((incoming) ? 0 : 3)
       default: ((incoming) ? 3 : 3)
    };



cached boolean hasActions(Controller controller, String type) :
	switch (type) {
	   case 'main'     : controller.actions.typeSelect(MainAction).size > 0 
	   case 'view'     : controller.actions.typeSelect(ViewAction).size > 0 
	   case 'display'  : controller.actions.typeSelect(DisplayAction).size > 0 
	   case 'edit'     : controller.actions.typeSelect(EditAction).size > 0
	   case 'delete'   : controller.actions.typeSelect(DeleteAction).size > 0
	   case 'custom'   : controller.actions.typeSelect(CustomAction).size > 0 
	   default : false
	};


/*
 * constants and labels for Doctrine
 */
cached String asConstant(DbTableType obj) :
    switch (obj) {
       case DbTableType::MYISAM : 'MYISAM'
       case DbTableType::INNODB : 'INNODB'
       default : ''
    };
cached String asConstant(EntityIndexType obj) :
    switch (obj) {
       case EntityIndexType::NORMAL     : ''/*dummy*/
       case EntityIndexType::UNIQUE     : 'unique'
       case EntityIndexType::FULLTEXT   : 'fulltext'
       case EntityIndexType::GIST       : 'gist'
       case EntityIndexType::GIN        : 'gin'
       default : ''
    };
cached String asConstant(CascadeType obj) :
    switch (obj) {
       case CascadeType::NONE           : ''/*dummy*/
       case CascadeType::CASCADE        : 'CASCADE'
       case CascadeType::SETNULL        : 'SET NULL'
       case CascadeType::NOACTION       : 'NO ACTION'
       case CascadeType::RESTRICT       : 'RESTRICT'
       case CascadeType::SETDEFAULT     : 'SET DEFAULT'
       default : ''
    };



/*
 * extensions that are independent of a specific model element,
 */

cached String fieldTypeAsString(DerivedField f)
    : f.metaType.toString().replaceAll("modulestudio::", "").replaceAll("Field", "").toLowerCase();
// required for own sub types like user, email, url, upload 
cached String fieldTypeAsString(AbstractIntegerField f)
    : 'integer';
cached String fieldTypeAsString(AbstractStringField f)
    : 'string';

cached String timestamp()
	: JAVA extensions.Utils.timestamp();

cached Boolean isProgressMonitor(Object monitor)
    : JAVA extensions.Utils.isProgressMonitor(java.lang.Object);

cached String subTask(Object monitor, String title)
    : monitor.isProgressMonitor() ? subTaskJava(monitor, title) : "";

cached String subTaskJava(Object monitor, String title)
	: JAVA extensions.Utils.subTask(org.eclipse.core.runtime.IProgressMonitor, java.lang.String);
